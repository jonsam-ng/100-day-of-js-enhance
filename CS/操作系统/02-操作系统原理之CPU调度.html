<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统原理之CPU调度</title>
    <meta name="description" content="100 days to enhance your skills on JavaScript.">
    <link rel="stylesheet" href="/assets/style.459f16fd.css">
    <link rel="modulepreload" href="/assets/chunks/virtual_search-data.e8a203cd.js">
    <link rel="modulepreload" href="/assets/chunks/vue3-pdf-embed.bc303c25.js">
    <link rel="modulepreload" href="/assets/chunks/vue3-video-player.common.509ef484.js">
    <link rel="modulepreload" href="/assets/chunks/vue-codemirror.esm.384db1e8.js">
    <link rel="modulepreload" href="/assets/chunks/index.cfa69757.js">
    <link rel="modulepreload" href="/assets/chunks/gitalk.e0595817.js">
    <link rel="modulepreload" href="/assets/app.f6484fa0.js">
    <link rel="modulepreload" href="/assets/CS_操作系统_02-操作系统原理之CPU调度.md.6e73f395.lean.js">
    
    <link rel="shortcut icon" href="/logo/favicon.ico" sizes="any">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#579871">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/logo/apple-touch-icon.png">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-63f8b582><!--[--><!--]--><!--[--><span tabindex="-1" data-v-51c7d2ac></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-51c7d2ac> Skip to content </a><!--]--><!----><header class="VPNav" data-v-63f8b582 data-v-8f5cf07d><div class="VPNavBar has-sidebar" data-v-8f5cf07d data-v-122aa4f8><div class="container" data-v-122aa4f8><div class="VPNavBarTitle has-sidebar" data-v-122aa4f8 data-v-da07d203><a class="title" href="/" data-v-da07d203><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo/favicon-16x16.png" alt data-v-982a05c4><!--]--><!--[-->100 days of JavaScript<!--]--><!--[--><!--]--></a></div><div class="content" data-v-122aa4f8><!--[--><!--]--><div class="VPNavBarSearch search" data-v-122aa4f8><!--teleport start--><!--teleport end--><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><span class="DocSearch-Button-Key">Meta</span><span class="DocSearch-Button-Key">K</span></span></button></div></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-122aa4f8 data-v-34c67e9e><span id="main-nav-aria-label" class="visually-hidden" data-v-34c67e9e>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 📂 CS <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" data-v-fae0e578 data-v-4990fafc><!--[-->📃 开始上手<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 操作系统<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 网络原理<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 📂 DSA <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/DSA/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" data-v-fae0e578 data-v-4990fafc><!--[-->📃 开始上手<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/DSA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 数据结构<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 🗳️ More <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/%E7%A4%BA%E4%BE%8B" data-v-fae0e578 data-v-4990fafc><!--[-->示例<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/%E5%85%B3%E4%BA%8E" data-v-fae0e578 data-v-4990fafc><!--[-->关于<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> ⛓️ Links <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://source.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->源码阅读<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://dsa.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->Fancy-DSA<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://ox.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->氧气空间<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="http://docs.jonsam.site/project-5/" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->深入学习设计模式<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://source.jonsam.site/nav" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->导航<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="https://www.jonsam.site" target="_blank" rel="noreferrer" data-v-34c67e9e data-v-148177db data-v-4990fafc><!--[-->📮 Blog<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-122aa4f8 data-v-132a39fa><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-132a39fa data-v-23f49a49 data-v-641a7590><span class="check" data-v-641a7590><span class="icon" data-v-641a7590><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-23f49a49><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-23f49a49><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-122aa4f8 data-v-34532fbd data-v-a0d6b759><!--[--><a class="VPSocialLink" href="https://github.com/jonsam-ng/100-day-of-js-enhance" target="_blank" rel="noopener" data-v-a0d6b759 data-v-902601b3><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-122aa4f8 data-v-2388b4fb data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d2d759f4><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-d2d759f4><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><!----><!--[--><!--[--><!----><div class="group" data-v-2388b4fb><div class="item appearance" data-v-2388b4fb><p class="label" data-v-2388b4fb>Appearance</p><div class="appearance-action" data-v-2388b4fb><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-2388b4fb data-v-23f49a49 data-v-641a7590><span class="check" data-v-641a7590><span class="icon" data-v-641a7590><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-23f49a49><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-23f49a49><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-2388b4fb><div class="item social-links" data-v-2388b4fb><div class="VPSocialLinks social-links-list" data-v-2388b4fb data-v-a0d6b759><!--[--><a class="VPSocialLink" href="https://github.com/jonsam-ng/100-day-of-js-enhance" target="_blank" rel="noopener" data-v-a0d6b759 data-v-902601b3><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-122aa4f8 data-v-84ae7409><span class="container" data-v-84ae7409><span class="top" data-v-84ae7409></span><span class="middle" data-v-84ae7409></span><span class="bottom" data-v-84ae7409></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-63f8b582 data-v-986ae53f><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-986ae53f><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-986ae53f><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-986ae53f>Menu</span></button><a class="top-link" href="#" data-v-986ae53f> Return to top </a></div><aside class="VPSidebar" data-v-63f8b582 data-v-aeceacfc><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-aeceacfc><span class="visually-hidden" id="sidebar-aria-label" data-v-aeceacfc> Sidebar Navigation </span><!--[--><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 CS</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 开始上手</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 操作系统</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 0-开始阅读</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 00-操作系统原理之概述</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 01-操作系统原理之进程与线程</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8BCPU%E8%B0%83%E5%BA%A6" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 02-操作系统原理之CPU调度</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 03-操作系统原理之调度算法</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 04-操作系统原理之进程同步</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AD%BB%E9%94%81" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 05-操作系统原理之死锁</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 网络原理</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 0-开始阅读</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 00-计算机网络原理之概述</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 01-计算机网络原理之物理层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 02-计算机网络原理之数据链路层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 03-计算机网络原理之网络层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 04-计算机网络原理之传输层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 05-计算机网络原理之应用层</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-63f8b582 data-v-431161ac><div class="VPDoc has-sidebar has-aside" data-v-431161ac data-v-16f25ed6><div class="container" data-v-16f25ed6><div class="aside" data-v-16f25ed6><div class="aside-curtain" data-v-16f25ed6></div><div class="aside-container" data-v-16f25ed6><div class="aside-content" data-v-16f25ed6><div class="VPDocAside" data-v-16f25ed6 data-v-9822eb1b><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-9822eb1b data-v-12a7ca3a><div class="content" data-v-12a7ca3a><div class="outline-marker" data-v-12a7ca3a></div><div class="outline-title" data-v-12a7ca3a>🔗 内容纲要：</div><nav aria-labelledby="doc-outline-aria-label" data-v-12a7ca3a><span class="visually-hidden" id="doc-outline-aria-label" data-v-12a7ca3a> Table of Contents for current page </span><ul class="root" data-v-12a7ca3a data-v-501ed047><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-9822eb1b></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-16f25ed6><div class="content-container" data-v-16f25ed6><!--[--><!--]--><main class="main" data-v-16f25ed6><div style="position:relative;" class="vp-doc _CS_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8BCPU%E8%B0%83%E5%BA%A6" data-v-16f25ed6><div><h1 id="操作系统原理之cpu调度" tabindex="-1">操作系统原理之 CPU 调度 <a class="header-anchor" href="#操作系统原理之cpu调度" aria-hidden="true">#</a></h1><div class="badge-group" data-v-4ecad2c5><span class="group-tag" data-v-4ecad2c5>标签：</span><!--[--><span class="badge tip" style="vertical-align:middle;" data-v-4ecad2c5 data-v-dd429f7e>操作系统原理</span><!--]--></div><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-hidden="true">#</a></h2><nav class="table-of-contents"><ul><li><a href="#目录">目录</a></li><li><a href="#cpu调度">CPU调度</a></li><li><a href="#什么是进程？">什么是进程？</a></li><li><a href="#进程存储器如何用于高效运行？">进程存储器如何用于高效运行？</a></li><li><a href="#什么是进程调度？">什么是进程调度？</a></li><li><a href="#为什么我们需要对进程进行调度？">为什么我们需要对进程进行调度？</a></li><li><a href="#对cpu调度算法的需求是什么？">对CPU调度算法的需求是什么？</a><ul><li><a href="#进程调度算法的目标">进程调度算法的目标</a></li></ul></li><li><a href="#cpu调度算法中的术语">CPU调度算法中的术语</a></li><li><a href="#在设计cpu调度算法时需要注意什么？">在设计CPU调度算法时需要注意什么？</a></li><li><a href="#cpu调度算法的类型">CPU调度算法的类型</a><ul><li><a href="#先到先服务（first-come-first-serve）">先到先服务（First Come First Serve）</a></li><li><a href="#最短作业优先（shortest-job-first）">最短作业优先（Shortest Job First）</a></li><li><a href="#最长作业优先（longest-job-first）">最长作业优先（Longest Job First）</a></li><li><a href="#基于优先级调度（priority-scheduling）">基于优先级调度（Priority Scheduling）</a></li><li><a href="#循环调度（round-robin）">循环调度（Round robin）</a></li><li><a href="#最短剩余时间优先（shortest-remaining-time-first）">最短剩余时间优先（Shortest Remaining Time First）</a></li><li><a href="#最长剩余时间优先（longest-remaining-time-first）">最长剩余时间优先（Longest Remaining Time First）</a></li><li><a href="#下一个最高响应比率（highest-response-ratio-next）">下一个最高响应比率（Highest Response Ratio Next）</a></li><li><a href="#多级队列调度（multilevel-queue-scheduling）">多级队列调度（Multilevel Queue Scheduling）</a></li><li><a href="#多级反馈队列调度（multilevel-feedback-queue-scheduling）">多级反馈队列调度（Multilevel Feedback Queue Scheduling）</a></li><li><a href="#各种cpu调度算法之间的比较">各种CPU调度算法之间的比较</a></li></ul></li><li><a href="#操作系统中的饥饿和老化">操作系统中的饥饿和老化</a><ul><li><a href="#饥饿现象">饥饿现象</a></li><li><a href="#饥饿的解决方案——老化">饥饿的解决方案——老化</a></li></ul></li><li><a href="#fcfs调度">FCFS调度</a><ul><li><a href="#fcfs特点">FCFS特点</a></li><li><a href="#fcfs优点">FCFS优点</a></li><li><a href="#fcfs缺点">FCFS缺点</a></li><li><a href="#fcfs原理">FCFS原理</a></li></ul></li><li><a href="#sjf调度">SJF调度</a><ul><li><a href="#sjf优点">SJF优点</a></li><li><a href="#sjf缺点">SJF缺点</a></li></ul></li><li><a href="#srtf调度">SRTF调度</a><ul><li><a href="#srtf示例">SRTF示例</a></li><li><a href="#包含cpu和io密集时间的srtf">包含CPU和IO密集时间的SRTF</a></li></ul></li><li><a href="#lrtf调度">LRTF调度</a><ul><li><a href="#lrtf特点">LRTF特点</a></li><li><a href="#lrtf优点">LRTF优点</a></li><li><a href="#lrtf缺点">LRTF缺点</a></li><li><a href="#lrtf原理">LRTF原理</a></li></ul></li><li><a href="#rr调度">RR调度</a><ul><li><a href="#rr优点">RR优点</a></li><li><a href="#rr缺点">RR缺点</a></li><li><a href="#自私的rr调度">自私的RR调度</a></li></ul></li><li><a href="#hrrn调度">HRRN调度</a></li><li><a href="#优先级调度">优先级调度</a><ul><li><a href="#非抢占式优先级调度">非抢占式优先级调度</a></li><li><a href="#抢占式优先级调度">抢占式优先级调度</a></li></ul></li><li><a href="#预测进程的cpu突发时间">预测进程的CPU突发时间</a><ul><li><a href="#静态技术">静态技术</a></li><li><a href="#动态技术">动态技术</a></li></ul></li></ul></nav><h2 id="cpu调度" tabindex="-1">CPU 调度 <a class="header-anchor" href="#cpu调度" aria-hidden="true">#</a></h2><p>对进程 / 工作进行调度是为了按时完成工作。CPU 调度是允许一个进程在另一个进程由于 I / O 等任何资源的不可用而被延迟（处于待机状态）时使用 CPU，从而充分利用 CPU 的过程。CPU 调度的目的是为了使系统更有效、更快速、更公平。</p><p>每当 CPU 变得空闲时，操作系统必须选择一个准备启动的进程。选择过程是由一个临时（CPU）调度器完成的。调度器在准备启动的内存进程（memory processes）之间进行选择，并将 CPU 分配给其中一个。</p><h2 id="什么是进程？" tabindex="-1">什么是进程？ <a class="header-anchor" href="#什么是进程？" aria-hidden="true">#</a></h2><p>在计算中，进程是一个计算机程序的实例（instance），由一个或多个线程执行。它包含程序代码和它的活动。根据操作系统（OS）的不同，一个进程可能是由多个执行线程（threads of execution）组成的，它们同时执行指令。</p><h2 id="进程存储器如何用于高效运行？" tabindex="-1">进程存储器如何用于高效运行？ <a class="header-anchor" href="#进程存储器如何用于高效运行？" aria-hidden="true">#</a></h2><p>进程存储器被分为四个部分以实现高效运行：</p><ul><li>文本类（text category）由集成的程序代码组成，在程序启动时从固定存储器（fixed storage）中读取。</li><li>数据类（data class）由全局变量和静态变量组成，在主动作（main action）之前分布和执行。</li><li>堆（heap）用于灵活的、或动态的内存分配，通过调用 new、delete、malloc、free 等来管理。</li><li>栈（stack）用于局部变量。堆栈中的空间在公布时被保留给局部变量。</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.3rn53pctnf20.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.3rn53pctnf20.webp"></p><h2 id="什么是进程调度？" tabindex="-1">什么是进程调度？ <a class="header-anchor" href="#什么是进程调度？" aria-hidden="true">#</a></h2><p>进程调度（Process Scheduling）是进程管理器（process manager）处理从 CPU 中移除一个活动进程并根据特定策略选择另一个进程的过程。</p><p>进程调度是多程序应用（Multi-programming）的一个组成部分。这样的操作系统允许一次加载一个以上的进程到可用的内存中，加载的共享 CPU 进程使用重复的时间。</p><p>有三种类型的进程调度器：</p><ul><li>长期的或工作调度器（Long term or Job Scheduler）</li><li>短期或 CPU 调度器（Short term or CPU Scheduler）</li><li>中期调度器（Medium-term Scheduler）</li></ul><h2 id="为什么我们需要对进程进行调度？" tabindex="-1">为什么我们需要对进程进行调度？ <a class="header-anchor" href="#为什么我们需要对进程进行调度？" aria-hidden="true">#</a></h2><p>调度（Scheduling）在许多不同的计算机环境中都很重要。其中一个最重要的领域是调度哪些程序将在 CPU 上工作。这项任务是由计算机的操作系统（OS）处理的，我们可以选择许多不同的方式来配置程序。</p><p>进程调度允许操作系统为每个进程分配 CPU 时间。使用进程调度系统的另一个重要原因是，它可以使 CPU 一直处于忙碌状态（busy at all times）。这可以使你获得更少的程序响应时间。</p><p>考虑到可能有数百个程序需要工作，操作系统必须启动程序，停止程序，切换到另一个程序，等等。操作系统配置另一个进程在 CPU 中运行的方式被称为 &quot;上下文切换&quot;（context switching）。如果操作系统不断地将程序在所提供的 CPU 中进行上下文切换，就会给用户一个感觉，即他可以同时运行任何他想运行的程序。</p><p>因此，现在我们知道我们可以在一个给定的 CPU 上运行 1 个程序，而且我们知道我们可以改变操作系统并使用上下文切换删除另一个程序，那么我们如何选择我们需要运行哪些程序，以及与什么程序一起运行？</p><p>这就是调度的作用！首先，你要确定指标（metrics），确立一些类似于 &quot;结束时间&quot;。我们将这个度量定义为 &quot;一个函数进入系统到完成的时间间隔&quot;。第二，你决定一个减少度量的度量。我们希望我们的任务能尽快结束。</p><h2 id="对cpu调度算法的需求是什么？" tabindex="-1">对 CPU 调度算法的需求是什么？ <a class="header-anchor" href="#对cpu调度算法的需求是什么？" aria-hidden="true">#</a></h2><p>CPU 调度是决定在另一个进程暂停时哪个进程将拥有 CPU 来使用的过程。CPU 调度的主要功能是确保每当 CPU 保持空闲时，操作系统至少选择了一个可用的进程在准备使用的名单中。</p><p>在多程序（Multiprogramming）中，如果长期调度器选择了多个 I/O 绑定的进程，那么在大多数时候，CPU 仍然是空闲的。一个有效程序的功能是提高资源利用率。</p><p>如果大多数操作系统将其状态从性能（performance）变为等待（waiting），那么系统中可能总是有失败的可能。因此，为了尽量减少这种过剩，操作系统需要安排任务，以便充分利用 CPU，避免出现死锁（deadlock）的可能性。</p><h3 id="进程调度算法的目标" tabindex="-1">进程调度算法的目标 <a class="header-anchor" href="#进程调度算法的目标" aria-hidden="true">#</a></h3><ul><li>将 CPU 的利用率提高到最高水平。保持 CPU 尽可能的繁忙。</li><li>CPU 的分配应该是公平的。</li><li>吞吐量（throughput）应该是最大的，即时间单位完成执行的进程数量应该是最大的。</li><li>最短的周转（turnaround）时间，即一个进程完成执行的时间应该是最少的。</li><li>应该有最小的等待时间，进程不应该在准备队列中饿死（starve）。</li><li>最小响应（response）时间。这意味着一个进程产生第一个响应的时间应该尽可能的短。</li></ul><h2 id="cpu调度算法中的术语" tabindex="-1">CPU 调度算法中的术语 <a class="header-anchor" href="#cpu调度算法中的术语" aria-hidden="true">#</a></h2><ul><li>到达时间（Arrival Time）：进程到达准备队列的时间。</li><li>完成时间（Completion Time）：进程完成其执行的时间。</li><li>执行时间（Burst Time）：进程在 CPU 执行所需的时间。</li><li>周转时间（Turn Around Time）：完成时间和到达时间之间的时间差。周转时间 = 完成时间 - 到达时间。</li><li>等待时间 (Waiting Time)：周转时间和执行时间之间的时间差。等待时间 = 周转时间 - 执行时间。</li></ul><h2 id="在设计cpu调度算法时需要注意什么？" tabindex="-1">在设计 CPU 调度算法时需要注意什么？ <a class="header-anchor" href="#在设计cpu调度算法时需要注意什么？" aria-hidden="true">#</a></h2><p>不同的 CPU 调度算法（CPU Scheduling algorithms）有不同的结构（structures），选择一个特定的算法取决于各种因素。许多条件已经被提出来用于比较 CPU 调度算法。这些条件包括以下几个方面：</p><ul><li>CPU 的利用率（CPU utilization）。任何 CPU 算法的主要目的都是为了让 CPU 尽可能的繁忙。理论上，CPU 的使用率可以从 0 到 100，但在实时系统中，根据系统负荷的不同，CPU 的使用率从 40% 到 90% 不等。</li><li>吞吐量（Throughput）。CPU 的平均性能是在每个单元度量（unit）中执行和完成的进程数量。这就是所谓的吞吐量。吞吐量可能根据进程的长度或持续时间而变化。</li><li>周转时间（Turn round Time）。对于一个特定的进程，重要的指标是执行该进程需要多长时间。从进程交付的时间到完成的时间被称为转换时间。<strong>转换时间是指等待内存访问、排队等待、使用 CPU 和等待 I/O 的时间</strong>。</li><li>等待时间（Waiting Time）：调度算法并不影响进程开始执行后完成所需的时间（执行时间）。它只影响进程的等待时间，即在准备队列中等待进程执行的时间。</li><li>响应时间（Response Time）：在一个协作系统中，周转时间不是最好的选择。进程可能会提前产生一些计算结果并继续计算新的结果，同时将以前的结果发布给用户。因此，另一种方法是在提交申请后直到发出第一个响应所花费的时间。这种方式被称为响应时间。</li></ul><h2 id="cpu调度算法的类型" tabindex="-1">CPU 调度算法的类型 <a class="header-anchor" href="#cpu调度算法的类型" aria-hidden="true">#</a></h2><p>主要有两种类型的调度方法：</p><ul><li>抢占式调度（Preemptive Scheduling）。抢占式调度是在进程从运行状态切换到就绪状态或从等待状态切换到就绪状态时使用。</li><li>非抢占式调度（Non-Preemptive Scheduling）。非抢占式调度是当一个进程终止时，或者当一个进程从运行状态切换到等待状态时使用的。</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4y1mng6zqm00.webp" alt="Different types of CPU Scheduling Algorithms" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4y1mng6zqm00.webp"></p><p>现在让我们逐一了解一下操作系统中的这些 CPU 调度算法。</p><h3 id="先到先服务（first-come-first-serve）" tabindex="-1">先到先服务（First Come First Serve） <a class="header-anchor" href="#先到先服务（first-come-first-serve）" aria-hidden="true">#</a></h3><p>FCFS（First Come First Serve）被认为是所有操作系统调度算法中最简单的一种。先到先服务的调度算法指出，抢先要求使用 CPU 的进程将首先被分配到 CPU，并通过使用先进先出队列（FIFO queue）来实现。</p><p>FCFS 的特点：</p><ul><li>FCFS 支持非抢先和抢占式的 CPU 调度算法。</li><li>任务总是以先到先服务的概念执行。</li><li>FCFS 很容易实现和使用。</li><li>这种算法在性能上不是很有效，而且等待时间相当长。</li></ul><p>FCFS 的优点：</p><ul><li>容易实现</li><li>先来后到的方法</li></ul><p>FCFS 的劣势：</p><ul><li>FCFS 受到 Convoy 效应（Convoy effect）的影响。</li><li>平均等待时间比其他算法高得多。</li><li>FCFS 非常简单，容易实现，因此效率不高。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>队列效应 (convoy effect)：所有其他进程都等待一个大进程释放 CPU，这称为队列效应。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.59aih3eucx80.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.59aih3eucx80.webp"></p><p>如果 CPU 在就绪队列种调度到较高突发时间（Burst Time）的进程，则较低突发时间的进程可能被阻塞，这意味着如果执行中的作业具有非常高的突发时间，则其余进程可能永远不会获得 CPU。这被称为<strong>队列效应（convoy effect）<strong>或</strong>饥饿（starvation）</strong>。</p><p>参考：</p><ul><li><a href="https://www.javatpoint.com/os-convoy-effect-in-fcfs" target="_blank" rel="noreferrer">OS Convoy Effect in FCFS - javatpoint</a></li></ul></div><h3 id="最短作业优先（shortest-job-first）" tabindex="-1">最短作业优先（Shortest Job First） <a class="header-anchor" href="#最短作业优先（shortest-job-first）" aria-hidden="true">#</a></h3><p>最短作业优先（SJF，Shortest Job First）是一种调度算法，它选择执行时间最小的等待进程来执行下一个作业。这种调度方法可能是也可能不是抢占式的。大大减少了其他等待执行的进程的平均等待时间。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.n2usxg3ko0w.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.n2usxg3ko0w.webp"></p><p>SJF 的特点：</p><ul><li>最短作业优先的优点是在所有操作系统调度算法中具有<strong>最小的平均等待时间</strong>。</li><li>它与每个任务都是以时间单元（a unit of time）完成的。</li><li>如果较短的进程不断出现，它可能会导致饥饿（starvation）。这个问题可以用老龄化（ageing）的概念来解决。</li></ul><p>最短作业优先的优点：</p><ul><li>由于 SJF 减少了平均等待时间，因此它比先来后到（先到先服务）的调度算法更好。</li><li>SJF 一般用于<strong>长期的调度</strong>。</li></ul><p>SJF 的缺点：</p><ul><li>SJF 的缺点之一是容易导致饥饿（starvation）。</li><li>很多时候，预测即将到来的 CPU 请求的长度（length）变得很复杂。</li></ul><h3 id="最长作业优先（longest-job-first）" tabindex="-1">最长作业优先（Longest Job First） <a class="header-anchor" href="#最长作业优先（longest-job-first）" aria-hidden="true">#</a></h3><p>最长作业优先 (LJF，Longest Job First) 调度过程与最短作业优先 (SJF) 相反，顾名思义，这种算法是基于具有最大突发时间（burst time）的进程被优先处理的原则。最长作业优先在本质上是非抢先性的。</p><p>LJF 的特点：</p><ul><li>在等待队列中的所有进程中，CPU 总是被分配给具有最大爆发时间的进程。</li><li>如果两个进程有相同的爆发时间，则使用 FCFS 打破平局，即先到的进程先被处理。</li><li>LJF CPU 调度可以是抢占式和非抢占式两种类型。</li></ul><p>LJF 的优点：</p><ul><li>在最长的工作或进程完全执行之前，没有其他任务会被调度。</li><li>所有的工作或进程大致在同一时间完成。</li></ul><p>LJF 的缺点：</p><ul><li>一般来说，LJF 算法对一组给定的进程会有非常高的平均等待时间和平均周转时间。</li><li>这可能会导致车队效应（convoy effect）。</li></ul><h3 id="基于优先级调度（priority-scheduling）" tabindex="-1">基于优先级调度（Priority Scheduling） <a class="header-anchor" href="#基于优先级调度（priority-scheduling）" aria-hidden="true">#</a></h3><p>抢占式优先级 CPU 调度算法（Preemptive Priority CPU Scheduling Algorithm）是一种抢占式的 CPU 调度算法方法，它根据进程的优先级来工作。在这种算法中，编辑者（editor）将功能标记为重要，也就是说，最重要的进程必须先做。在有任何冲突的情况下，即有一个以上的进程具有相同的优先级，那么最主要的 CPU 规划算法将在 FCFS（先到先得）算法的基础上工作。</p><p>优先级调度的特点：</p><ul><li>根据优先级来安排任务。</li><li>当优先级较高的工作到达时，而优先级较低的任务正在执行，优先级较高的工作就取代了优先级较低的工作，并且后者被暂停，直到前者执行完毕。</li><li>分配的优先级数字（number）越低，进程的优先级就越高。</li></ul><p>优先级调度的优点：</p><ul><li>平均等待时间比 FCFS 少</li><li>不太复杂</li></ul><p>优先级调度的缺点：</p><p>抢占式优先级 CPU 调度算法最常见的缺点之一是饥饿问题。当一个进程必须等待较长的时间才能被调度到 CPU 的问题，这种情况被称为 &quot;饥饿问题&quot;。</p><h3 id="循环调度（round-robin）" tabindex="-1">循环调度（Round robin） <a class="header-anchor" href="#循环调度（round-robin）" aria-hidden="true">#</a></h3><p>循环调度（Round Robin）是一种 CPU 调度算法，每个进程都被循环地分配一个固定的时间段片。它是先到先服务的 CPU 调度算法的抢占性版本。Round Robin CPU 算法一般侧重于时间共享技术（Time Sharing technique）。</p><p>循环调度的特点：</p><ul><li>它很简单，容易使用，而且没有饥饿现象，因为所有进程都能得到均衡的 CPU 分配。</li><li>是内核（core）的 CPU 调度中最广泛使用的方法之一。</li><li>它被认为是抢占式（preemptive）的，因为进程被赋予 CPU 的时间非常有限。</li></ul><p>循环调度的优点：</p><ul><li>循环调度似乎是公平的，因为每个进程都共享到同等份额的 CPU。</li><li>新创建的进程被添加到就绪队列（ready queue）的末端。</li></ul><h3 id="最短剩余时间优先（shortest-remaining-time-first）" tabindex="-1">最短剩余时间优先（Shortest Remaining Time First） <a class="header-anchor" href="#最短剩余时间优先（shortest-remaining-time-first）" aria-hidden="true">#</a></h3><p>最短剩余时间优先（Shortest Remaining Time First，SRTF）是我们前面讨论过的最短工作优先的抢占式版本，即处理器被分配给最接近完成的工作。在 SRTF 中，选择完成前剩余时间最小的进程来执行。</p><p>最短剩余时间优先的特点：</p><ul><li>SRTF 算法使作业的处理比 SJF 算法快，因为它的开销不被计算在内。</li><li>在 SRTF 中，上下文切换的次数比 SJF 多得多，消耗了 CPU 的宝贵处理时间。这增加了它的处理时间，削弱了它快速处理的优势。</li></ul><p>SRTF 的优点：</p><ul><li>在 SRTF 中，短进程（short processes）的处理速度非常快。</li><li>该系统也只需要很少的开销（overhead），因为它只在一个进程完成或增加一个新的进程时做出决定。</li></ul><p>SRTF 的劣势：</p><ul><li>像最短作业优先一样，它也有可能造成进程饥饿。</li><li>如果短的进程不断被添加，长的进程可能会被无限期地搁置。</li></ul><h3 id="最长剩余时间优先（longest-remaining-time-first）" tabindex="-1">最长剩余时间优先（Longest Remaining Time First） <a class="header-anchor" href="#最长剩余时间优先（longest-remaining-time-first）" aria-hidden="true">#</a></h3><p>最长剩余时间优先（Longest Remaining Time First，LRTF）是最长工作优先调度算法的一个抢占性版本。这种调度算法被操作系统用来对进入的进程进行系统的编程使用。这种算法首先调度那些剩余处理时间最长的进程，以便完成。</p><p>最长剩余时间优先的特点：</p><ul><li>在等待队列中的所有进程中，CPU 总是被分配给具有最大突发时间（burst time）的进程。</li><li>如果两个进程有相同的突发时间，那么就用 FCFS 打破平局，即先到的进程先被处理。</li><li>LJF CPU 调度可以是抢占式和非抢占式两种类型。</li></ul><p>LRTF 的优点：</p><ul><li>在最长的任务完全执行之前，其他进程不会被执行。</li><li>所有的工作或进程大约在同一时间完成。</li></ul><p>LRTF 的缺点：</p><ul><li>这种算法对给定的一组进程会有很高的平均等待时间和平均周转时间。</li><li>这可能导致车队效应。</li></ul><h3 id="下一个最高响应比率（highest-response-ratio-next）" tabindex="-1">下一个最高响应比率（Highest Response Ratio Next） <a class="header-anchor" href="#下一个最高响应比率（highest-response-ratio-next）" aria-hidden="true">#</a></h3><p>下一个最高响应比率（Highest Response Ratio Next，HRRN）算法是一种非抢占式的 CPU 调度算法，它被认为是最优化的调度算法之一。这个名字本身就说明，我们需要找到所有可用进程的响应比率（Response Ratio），并选择一个具有最高响应比率的进程。一个进程一旦被选中就会一直运行到完成。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>响应比 =（W+S）/S，这里，W 是到目前为止进程的等待时间，S 是进程的突发时间。</p></div><p>HRRN 特点：</p><ul><li>HRRN 的标准（criteria）是响应率，模式（mode）是非抢占式。</li><li>HRRN 被认为是对最短作业优先的修改，以减少饥饿问题。</li><li>与 SJF 相比，在 HRRN 调度算法中，CPU 被分配给具有最高响应比率的下一个进程，而不是分配给具有较少突发时间的进程。</li></ul><p>HRRN 的优势：</p><ul><li>HRRN 调度算法通常比最短作业优先调度的性能更好。</li><li>长作业的等待时间减少了，而且它鼓励短作业。</li></ul><p>HRRN 的缺点：</p><ul><li>HRRN 调度的实施是不可能的，因为它不可能事先知道每个作业的突发时间。</li><li>在这种调度中，可能会出现 CPU 过载的情况。</li></ul><h3 id="多级队列调度（multilevel-queue-scheduling）" tabindex="-1">多级队列调度（Multilevel Queue Scheduling） <a class="header-anchor" href="#多级队列调度（multilevel-queue-scheduling）" aria-hidden="true">#</a></h3><p>准备队列中的进程可以被分为不同的类别，其中每个类别都有自己的调度需求（scheduling needs）。例如，一个常见的划分是前台（互动，foreground (interactive)）进程和后台（批处理，background (batch)）进程。这两个类有不同的调度需求。对于这种情况，可以使用多级队列调度。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.3c61608gcdg0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.3c61608gcdg0.webp"></p><p>上述图表中的过程描述如下：</p><ul><li>系统进程（System Processes）。CPU 本身有其运行的进程，一般称为系统进程。</li><li>交互式进程（Interactive Processes）。交互式进程是一种有相同类型的交互的进程。</li><li>批处理进程（Batch Processes）。批处理是操作系统中的一种技术，它在进程开始之前将程序和数据以批量的形式收集在一起。</li></ul><p>多级队列调度的特点：</p><p>在多级队列调度算法中，进程在进入系统时被永久地分配到一个队列中，而进程不允许在队列之间移动。由于进程被永久地分配到队列中，这种设置具有低调度开销的优点。但另一方面也有不灵活的缺点。</p><p>多级队列调度的优点：</p><ul><li>多级队列的主要优点是它的调度开销低。</li></ul><p>多级队列调度的劣势：</p><ul><li>饥饿问题</li><li>本质上是不灵活</li></ul><h3 id="多级反馈队列调度（multilevel-feedback-queue-scheduling）" tabindex="-1">多级反馈队列调度（Multilevel Feedback Queue Scheduling） <a class="header-anchor" href="#多级反馈队列调度（multilevel-feedback-queue-scheduling）" aria-hidden="true">#</a></h3><p>多级反馈队列调度（MLFQ，Multilevel Feedback Queue Scheduling）CPU 调度与多级队列调度一样，但在这个过程中可以在队列之间移动。因此，比多级队列调度的效率要高得多。</p><p>多级反馈队列调度的特点：</p><ul><li>由于进程允许在不同队列之间移动，具有一定灵活性，同时增加了部分的调度开销。</li></ul><p>多级反馈队列调度的优点：</p><ul><li>它更灵活</li><li>它允许不同的进程在不同的队列之间移动。</li></ul><p>多级反馈队列调度的缺点：</p><ul><li>它也会产生 CPU 的开销</li><li>它是最复杂的算法。</li></ul><h3 id="各种cpu调度算法之间的比较" tabindex="-1">各种 CPU 调度算法之间的比较 <a class="header-anchor" href="#各种cpu调度算法之间的比较" aria-hidden="true">#</a></h3><p>下面是不同 CPU 调度算法之间的简要比较。</p><table><thead><tr><th>算法</th><th>CPU 分配</th><th>复杂性</th><th>平均等待时间（AWT）</th><th>抢占式</th><th>饥饿现象</th><th>性能</th></tr></thead><tbody><tr><td>FCFS</td><td>根据进程的到达时间，分配 CPU。</td><td>简单且容易实现</td><td>大</td><td>否</td><td>否</td><td>性能差</td></tr><tr><td>SJF</td><td>基于最低的 CPU 突发时间（BT）。</td><td>比 FCFS 更复杂</td><td>比 FCFS 小</td><td>否</td><td>是</td><td>最小的平均等待时间</td></tr><tr><td>LJF</td><td>基于最高的 CPU 突发时间（BT）</td><td>比 FCFS 更复杂</td><td>取决于一些因素，如到达时间、进程大小等。</td><td>否</td><td>是</td><td>很大的周转时间</td></tr><tr><td>LRTF</td><td>与 LJF 相同，CPU 的分配是基于最高的 CPU 突发时间（BT）。但它是抢占式的</td><td>比 FCFS 更复杂</td><td>取决于一些因素，如到达时间、进程大小等。</td><td>是</td><td>是</td><td>优先考虑较长的工作</td></tr><tr><td>SRTF</td><td>与 SJF 一样，CPU 的分配是基于最低的 CPU 突发时间（BT）。但它是抢占式的</td><td>比 FCFS 更复杂</td><td>取决于一些因素，如到达时间、进程大小等。</td><td>是</td><td>是</td><td>优先考虑短作业</td></tr><tr><td>RR</td><td>根据进程的顺序，以固定的时间片（TQ，time quantum）到达</td><td>复杂性取决于时间片的大小</td><td>与 SJF 和优先级调度相比较大。</td><td>是</td><td>否</td><td>每个进程都有一个相当固定的时间</td></tr><tr><td>抢占式优先级调度</td><td>根据优先级。优先级大的任务先执行</td><td>这种类型不太复杂</td><td>比 FCFS 小</td><td>是</td><td>是</td><td>性能良好，但包含饥饿问题</td></tr><tr><td>非抢占式优先级调度</td><td>根据优先级监控新进入的更高优先级的作业</td><td>这种类型没有优先级抢占式那么复杂</td><td>抢占式比 FCFS 小</td><td>否</td><td>是</td><td>对批处理系统最有利</td></tr><tr><td>MLQ</td><td>根据进程所在更高优先级的队列</td><td>比优先级调度算法更复杂</td><td>比 FCFS 小</td><td>否</td><td>是</td><td>性能良好，但包含饥饿问题</td></tr><tr><td>MFLQ</td><td>根据进程所在更高优先级的队列</td><td>它是最复杂的，但其复杂率取决于 TQ（time quantum）的大小</td><td>在许多情况下比所有调度类型都小。</td><td>否</td><td>否</td><td>性能良好</td></tr></tbody></table><h2 id="操作系统中的饥饿和老化" tabindex="-1">操作系统中的饥饿和老化 <a class="header-anchor" href="#操作系统中的饥饿和老化" aria-hidden="true">#</a></h2><h3 id="饥饿现象" tabindex="-1">饥饿现象 <a class="header-anchor" href="#饥饿现象" aria-hidden="true">#</a></h3><p>优先级调度是批处理系统中最常见的调度算法之一。每个进程都被分配了一个优先级，具有最高优先级的进程将被首先执行，以此类推。这里我们将讨论一个与优先级调度有关的主要问题和它的解决方案。</p><p>饥饿（Starvation）或无限期阻塞（indefinite blocking）是一种与优先级调度算法有关的现象，在这种情况下，一个准备获得 CPU（资源）的进程可能因为低优先级而无限期地等待运行。在一个高负荷的计算机系统中，源源不断的高优先级进程可以阻止低优先级的进程获得 CPU。有传言说，1967 年优先级调度在麻省理工学院的 IBM 7094 中使用，他们发现一个低优先级的进程，直到 1973 年才被提交。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.2e7p7jj258nw.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.2e7p7jj258nw.webp"></p><p>正如我们在上面的例子中所看到的，比其他进程拥有更高的优先级的进程更早获得 CPU。我们可以考虑这样一种情况，即只有一个进程具有非常低的优先级（例如 127），而我们给其他进程以高优先级，这可能导致具有低优先级的进程无限期地等待获得 CPU，这就导致了饥饿现象。此外，我们将讨论饥饿现象的解决办法。</p><p>操作系统中的死锁（Deadlock）和饥饿的区别如下：</p><ul><li>由于其他进程占用了所需的资源，没有一个进程能够前进，这时就会出现死锁；另一方面，当一个进程无限期地等待获得它所需要的资源时，就会出现饥饿现象。</li><li>死锁的另一个名称是循环等待（Circular Waiting）。饥饿现象的另一个名字是活锁（Lived lock）。</li><li>当死锁发生时，任何进程都不能取得进展，而在饥饿状态下，除了受害者进程外，其他进程可以取得进展或进行。</li></ul><h3 id="饥饿的解决方案——老化" tabindex="-1">饥饿的解决方案 —— 老化 <a class="header-anchor" href="#饥饿的解决方案——老化" aria-hidden="true">#</a></h3><p>老化（Aging）是一种逐步提高在系统中等待了很长时间的进程的优先级的技术。例如，如果优先级范围从 127（低）到 0（高），我们可以每 15 分钟给等待进程的优先级加 1。最终，即使是一个初始优先级为 127 的进程，也最多不超过 32 个小时的时间，就能使之老化为优先级为 0 的进程。</p><h2 id="fcfs调度" tabindex="-1">FCFS 调度 <a class="header-anchor" href="#fcfs调度" aria-hidden="true">#</a></h2><p>FCFS 是先到先服务（First Come First Serve）的意思。在 FCFS 调度算法中，首先到达准备队列（ready queue）的作业被分配到 CPU，然后是第二个到达的作业，以此类推。我们可以说准备队列是一个先进先出（FIFO）队列，因此到达的作业 / 进程被放在队列的最后。</p><p>FCFS 是一种非抢占式的调度算法，因为一个进程会占据 CPU，直到它终止或执行 I/O。因此，如果一个较长的作业被分配到 CPU，那么在它之后的许多较短的作业将不得不等待。这种算法在大多数批处理操作系统中使用。</p><h3 id="fcfs特点" tabindex="-1">FCFS 特点 <a class="header-anchor" href="#fcfs特点" aria-hidden="true">#</a></h3><ul><li>它遵循<strong>非抢占式</strong>方法，即一旦一个进程控制了 CPU，它就不会被抢占（preempt），直到它终止。</li><li>选择进程的标准是<strong>到达时间</strong>（arrival time）。调度器选择就绪队列中的第一个工作，这个工作运行到完成其 CPU 执行（CPU burst）。</li><li>平均等待时间很高，所以不是最佳选择，因此性能很差。</li></ul><h3 id="fcfs优点" tabindex="-1">FCFS 优点 <a class="header-anchor" href="#fcfs优点" aria-hidden="true">#</a></h3><ul><li>FCFS 算法很简单，容易在任何已有的系统中实现，而且容易理解。</li><li>由于进程之间不涉及上下文切换，因此更适合于有大量突发时间（large burst time）的进程。</li><li>它是一种公平的算法，因为不涉及优先级，先到的进程先得到服务。</li></ul><h3 id="fcfs缺点" tabindex="-1">FCFS 缺点 <a class="header-anchor" href="#fcfs缺点" aria-hidden="true">#</a></h3><ul><li>会出现队列效应（convoy effect），即所有的小进程都要等待一个大进程离开 CPU。</li><li>它是非抢占式的，进程在完成其任务并终止之前不会释放 CPU。</li><li>它不适合于交互式系统，因为它不能保证短的响应时间。</li><li>平均等待时间很高，周转时间不可预测，导致性能不佳。</li></ul><h3 id="fcfs原理" tabindex="-1">FCFS 原理 <a class="header-anchor" href="#fcfs原理" aria-hidden="true">#</a></h3><p>第一个进程的等待时间为 0，因为它首先被执行。接下来的进程的等待时间可以通过以下方式计算： <code>wt[i] = ( at[i - 1] + bt[i - 1] + wt[i - 1] ) - at[i]</code> 。</p><p>其中：</p><ul><li><code>wt[i]</code> = 当前进程的等待时间</li><li><code>at[i-1]</code> = 前一个进程的到达时间</li><li><code>bt[i-1]</code> = 前一进程的突发时间</li><li><code>wt[i-1]</code> = 前一进程的等待时间</li><li><code>at[i]</code> = 当前进程的到达时间</li></ul><p>平均等待时间可以通过以下方式计算：平均等待时间 =（所有等待时间的总和）/（进程数）。</p><h2 id="sjf调度" tabindex="-1">SJF 调度 <a class="header-anchor" href="#sjf调度" aria-hidden="true">#</a></h2><p>SJF 调度算法是根据进程的突发时间（burst time）来调度的。在 SJF 调度中，在就绪队列中的可用进程列表中，具有最低突发时间的进程将被安排在下一个。然而，预测一个进程所需的突发时间是非常困难的，因此这种算法在系统中很难实现。</p><h3 id="sjf优点" tabindex="-1">SJF 优点 <a class="header-anchor" href="#sjf优点" aria-hidden="true">#</a></h3><ul><li>最大的吞吐量</li><li>最小的平均等待和周转时间</li></ul><h3 id="sjf缺点" tabindex="-1">SJF 缺点 <a class="header-anchor" href="#sjf缺点" aria-hidden="true">#</a></h3><ul><li>可能会出现饥饿问题</li><li>无法实现，因为进程的确切突发时间无法事先知道。（有不同的技术可以用来确定进程的 CPU 突发时间。我们将在后面详细讨论这些技术）。</li></ul><h2 id="srtf调度" tabindex="-1">SRTF 调度 <a class="header-anchor" href="#srtf调度" aria-hidden="true">#</a></h2><p>这个算法是 SJF 调度的抢占式版本（preemptive version）。在 SRTF 中，进程的执行可以在一定的时间后停止。在每个进程到达时，短期调度器会在可用的进程列表和正在运行的进程中安排剩余突发时间最少的进程进行调度。</p><p><strong>一旦所有的进程都在就绪队列中，将不进行抢占，该算法将作为 SJF 调度工作</strong>。当进程从执行中移除下一个进程被调度时，进程的上下文被保存在进程控制块（Process Control Block）中。这个 PCB 在这个进程的下一次执行时被访问。</p><h3 id="srtf示例" tabindex="-1">SRTF 示例 <a class="header-anchor" href="#srtf示例" aria-hidden="true">#</a></h3><p>在这个例子中，有五个工作 P1, P2, P3, P4, P5 和 P6。他们的到达时间和突发时间如下表所示：</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.41l23ovi6po0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.41l23ovi6po0.webp"></p><p>平均等待时间 = 24/6</p><p>甘特图是根据表格中给出的到达和突发时间编制的。</p><ul><li>因为在时间 0，唯一可用的进程是 CPU 突发时间为 8 的 P1。这是列表中唯一可用的进程，因此它被安排。</li><li>下一个进程在时间单元 1 到达。由于我们使用的算法是 SRTF，它是一种抢占式的算法，当前的执行被停止，调度器检查具有最小突发时间的进程。</li><li>到现在为止，在准备队列中有两个进程。操作系统到现在为止已经执行了 P1 一个单位的时间；P1 的剩余突发时间是 7 个单位。进程 P2 的突发时间是 4 个单位。因此，根据算法，进程 P2 被安排在 CPU 上。</li><li>下一个进程 P3 在时间单位 2 到达。在这个时候，进程 P3 的执行被停止，并寻找剩余突发时间最少的进程。由于进程 P3 有 2 个单位的突发时间，因此它将被赋予比其他进程更多的优先权。</li><li>下一个进程 P4 在时间单位 3 到达。在这个时候，调度器将停止 P4 的执行，并检查在可用的进程（P1、P2、P3 和 P4）中哪个进程的突发时间最少。P1 和 P2 分别有 7 个单位和 3 个单位的剩余突发时间。</li><li>P3 和 P4 的剩余突发时间各为 1 个单位。由于两者相等，因此调度将根据他们的到达时间进行。P3 比 P4 早到，因此它将被再次调度。</li><li>下一个进程 P5 在时间单位 4 到达。直到这个时候，进程 P3 已经完成了它的执行，它已经不在列表中了。调度器将比较所有可用进程的剩余突发时间。由于进程 P4 的突发时间是 1，是所有进程中最少的，因此它将被调度。</li><li>下一个进程 P6 在时间单元 5 到达，直到这时，进程 P4 已经完成了它的执行。到目前为止，我们有 4 个可用的进程，即 P1（7）、P2（3）、P5（3）和 P6（2）。P6 的突发时间是所有进程中最少的，因此 P6 被安排了。因为现在所有的进程都是可用的，所以现在的算法将与 SJF 一样工作。P6 将被执行，直到其完成，然后剩余时间最少的进程将被安排。</li></ul><p>一旦所有进程都到达，就不会有抢占行为，算法将像 SJF 一样工作。</p><h3 id="包含cpu和io密集时间的srtf" tabindex="-1">包含 CPU 和 IO 密集时间的 SRTF <a class="header-anchor" href="#包含cpu和io密集时间的srtf" aria-hidden="true">#</a></h3><p>到现在为止，我们只考虑了与 CPU 绑定的作业。然而，进程可能需要一些 IO 操作或一些资源来完成其执行。在本例中，我们考虑的是 IO 绑定的进程。参见：<a href="https://www.javatpoint.com/os-srtf-with-processes-contains-cpu-and-io-time" target="_blank" rel="noreferrer">SRTF with Processes contains CPU and IO Time</a></p><h2 id="lrtf调度" tabindex="-1">LRTF 调度 <a class="header-anchor" href="#lrtf调度" aria-hidden="true">#</a></h2><p>最长剩余时间优先（LRTF，Longest Remaining Time First）是最长工作优先（LJF）调度算法的一个抢占性版本。在这种调度算法中，我们找到具有最大剩余时间的进程，然后对其进行处理，即在一定的时间间隔后检查最大剩余时间，以检查是否有另一个具有更多突发时间的进程到达该时间。</p><h3 id="lrtf特点" tabindex="-1">LRTF 特点 <a class="header-anchor" href="#lrtf特点" aria-hidden="true">#</a></h3><ul><li>在等待队列中的所有进程中，CPU 总是分配给具有最大突发时间的进程。</li><li>如果两个进程有相同的突发时间，那么就用 FCFS 打破平局，即先到的进程先被处理。</li><li>LJF CPU 调度可以是抢占式和非抢占式的。</li></ul><h3 id="lrtf优点" tabindex="-1">LRTF 优点 <a class="header-anchor" href="#lrtf优点" aria-hidden="true">#</a></h3><ul><li>在最长的工作或进程完全执行之前，没有其他进程可以执行。</li><li>所有的工作或进程大约在同一时间完成。</li></ul><h3 id="lrtf缺点" tabindex="-1">LRTF 缺点 <a class="header-anchor" href="#lrtf缺点" aria-hidden="true">#</a></h3><ul><li>这种算法对一组给定的进程给出非常高的平均等待时间和平均周转时间。</li><li>这可能导致车队效应。</li><li>可能发生的情况是，一个短的进程可能永远不会被执行，而系统一直在执行长的进程。</li><li>这降低了处理速度，从而降低了系统的效率和利用率。</li></ul><h3 id="lrtf原理" tabindex="-1">LRTF 原理 <a class="header-anchor" href="#lrtf原理" aria-hidden="true">#</a></h3><ul><li>第 1 步：首先，按照到达时间的递增顺序对进程进行排序。</li><li>第 2 步：选择到达时间最少但突发时间最多的进程。</li><li>第 3 步：然后对其进行 1 个时间单元（时间片）的处理。检查是否有其他进程到达该执行时间。</li><li>第 4 步：重复上述两个步骤，直到执行所有的进程。</li></ul><h2 id="rr调度" tabindex="-1">RR 调度 <a class="header-anchor" href="#rr调度" aria-hidden="true">#</a></h2><p>Round Robin（RR）调度算法是最流行的调度算法之一，实际上可以在大多数操作系统中实现。这是 FCFS 的调度方式的抢占式版本。该算法的重点是时间共享（Time Sharing）。在这个算法中，每个进程都以循环的方式（cyclic way）执行。在系统中定义了一个特定的时间片（time slice），这被称为时间量子（time quantum，TQ）。在准备队列中的每个进程都被分配到该时间量的 CPU，如果该进程的执行在该时间段内完成，那么该进程将被终止，否则该进程将回到准备队列（ready queue）中，等待下一次轮到完成执行。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4vxilf8b3gc0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4vxilf8b3gc0.webp"></p><h3 id="rr优点" tabindex="-1">RR 优点 <a class="header-anchor" href="#rr优点" aria-hidden="true">#</a></h3><ul><li>它可以在系统中实际执行，因为它<strong>不依赖于突发时间</strong>。</li><li>它不存在饥饿或车队效应的问题。</li><li>所有的工作都能得到 CPU 的分配。</li></ul><h3 id="rr缺点" tabindex="-1">RR 缺点 <a class="header-anchor" href="#rr缺点" aria-hidden="true">#</a></h3><ul><li><strong>时间量子越高，系统的响应时间就越长</strong>。</li><li><strong>时间量子越低，系统中的上下文切换开销就越大</strong>。</li><li>决定一个完美的时间量子在系统中确实是一个非常困难的任务。</li></ul><h3 id="自私的rr调度" tabindex="-1">自私的 RR 调度 <a class="header-anchor" href="#自私的rr调度" aria-hidden="true">#</a></h3><p>在传统的 Round Robin 调度算法中，所有的进程都被平等地对待，进行处理。自私的 Round Robin 的目标是给已经执行了一段时间的进程提供比新来者更好的服务。与普通的 Round Robin 算法相比，它是一个更合理、更优越的实现。</p><p>原理：</p><ul><li>准备好的列表（ready list）中的进程被划分为两个列表。新的（NEW）和已接受的（ACCEPTED）。</li><li>新进程等待，而已接受的的进程则由 Round Robin 提供服务。</li><li>一个新进程的优先级以 &#39;a&#39; 的速度增加，而一个已接受的的进程的优先级以 &#39;b&#39; 的速度增加。</li><li>当一个新进程的优先级达到一个已接受的的进程的优先级时，该新进程被接受。</li><li>如果所有被接受的进程都完成了，则优先级最高的新进程被接受。</li></ul><h2 id="hrrn调度" tabindex="-1">HRRN 调度 <a class="header-anchor" href="#hrrn调度" aria-hidden="true">#</a></h2><p>下一个最高响应率（HRNN，Highest Response Ratio Next）是最优化的调度算法之一。这是一种非抢占式的算法，在这种算法中，调度是基于一个叫做<strong>响应比</strong>的额外参数进行的。响应比是为每个可用的工作计算的，具有最高响应比的工作被赋予比其他工作更多的优先权。</p><p>响应比率是通过给定的公式计算的，即 <code>Response Ratio = (W+S)/S</code> 。其中 W 为等待时间，S 为服务时间或突发时间。如果我们看一下这个公式，我们会注意到，突发时间较短的工作将被优先考虑，但它也包括一个额外的因素，称为等待时间。因此：HRNN 与 W 成正比，与 S 成反比。</p><p>这种算法不仅有利于较短的工作，而且也关注较长工作的等待时间。它的模式是非抢占式的，因此在这个算法中上下文切换是最小的。</p><h2 id="优先级调度" tabindex="-1">优先级调度 <a class="header-anchor" href="#优先级调度" aria-hidden="true">#</a></h2><p>在优先级调度（Priority Scheduling）中，有一个优先级号码分配给每个进程。在一些系统中，数字越小，优先级就越高。而在其他系统中，数字越大，优先级就越高。在可用的进程中具有较高优先级的进程被赋予 CPU。有两种类型的优先级调度算法存在：一种是抢占式优先级调度，另一种是非抢占式优先级调度。</p><p>分配给每个进程的优先权号码可能会或也可能不会变化。如果优先权号码在整个过程中不发生变化，它就被称为<strong>静态优先权</strong>，而如果它在固定的时间段内不断改变自己，它就被称为<strong>动态优先权</strong>。</p><h3 id="非抢占式优先级调度" tabindex="-1">非抢占式优先级调度 <a class="header-anchor" href="#非抢占式优先级调度" aria-hidden="true">#</a></h3><p>在非抢占式优先级调度（Non Preemptive Priority Scheduling）中，进程是根据分配给它们的优先级编号来调度的。一旦进程被调度，它将一直运行到完成。一般来说，优先级数字越低，进程的优先级就越高。人们可能会对优先级的数字感到困惑，因此在 GATE 中，明确提到了哪一个是最高的优先级，哪一个是最低的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Turn Around Time = Completion Time - Arrival Time Waiting Time = Turn Around Time - Burst Time</p></div><h3 id="抢占式优先级调度" tabindex="-1">抢占式优先级调度 <a class="header-anchor" href="#抢占式优先级调度" aria-hidden="true">#</a></h3><p>在抢占式优先级调度（Preemptive Priority Scheduling）中，<strong>当一个进程到达就绪队列时</strong>，它的优先级将与就绪队列中的其他进程的优先级以及在该时间点正在由 CPU 执行的进程的优先级进行比较。在所有可用的进程中具有最高优先级的进程将被赋予 CPU。</p><p>抢占式优先级调度和非抢占式优先级调度的区别在于，在抢占式优先级调度中，正在执行的工作可以在更高优先级的工作到来时被停止。</p><p>一旦所有的工作都在准备好的队列中，该算法将表现为非抢占式优先级调度，这意味着安排的工作将运行到完成，不会有抢占的情况发生。</p><h2 id="预测进程的cpu突发时间" tabindex="-1">预测进程的 CPU 突发时间 <a class="header-anchor" href="#预测进程的cpu突发时间" aria-hidden="true">#</a></h2><p>SJF 算法是最好的调度算法之一，因为它提供了最大的吞吐量和最小的等待时间，但该算法的问题是，CPU 的爆发时间不能事先知道。但是我们可以对一个进程的 CPU 突发时间进行近似计算。有各种技术可以用来预测一个进程的 CPU 突发时间。</p><p>以下是用于预测一个进程的 CPU 突发时间的技术：</p><h3 id="静态技术" tabindex="-1">静态技术 <a class="header-anchor" href="#静态技术" aria-hidden="true">#</a></h3><p>进程大小（Process Size）：</p><p>我们可以根据进程的大小来预测它的突发时间。如果我们有两个进程 T_OLD 和 T_New，旧进程的实际突发时间为 20 秒，进程的大小为 20KB。我们知道 P_NEW 的大小是 21KB。那么 P_NEW 的突发时间与 20 秒相似的概率是很大的。因此，在这项技术中，我们实际上是根据与新进程大小相似的旧进程的突发时间来预测新进程的突发时间。</p><p>进程类型（Process Type）：</p><p>我们还可以根据进程的类型来预测进程的突发时间。一个进程可以有各种类型，定义如下：</p><ul><li>操作系统进程（OS Process）：一个进程可以是一个操作系统进程，如调度器、编译器、程序管理器和许多其他系统进程。它们的突发时间一般较低，例如，3 到 5 个单位的时间。</li><li>用户进程（User Process）：由用户发起的进程被称为用户进程。可以有以下三种类型的进程： <ul><li>交互式进程（Interactive Process）：交互式进程是一种不时与用户互动的进程，其执行完全取决于用户的输入，例如各种游戏就是这样的进程。由于它们不需要大量的 CPU，所以它们的突发时间要低一些，它们主要取决于用户与进程的交互性，因此它们主要是 IO 密集（IO bound）的进程。</li><li>前台进程（Foreground process）：前台进程是用户用来执行其需求的进程，如 MS office、Editors、实用软件等。这些类型的进程有较高的突发时间，因为它们是 CPU 和 IO 密集进程的完美结合。</li><li>后台进程（Background process）：后台进程支持其他进程的执行。它们以隐藏模式工作（hidden mode）。例如，键盘记录器是记录用户按下的键和用户在系统上的活动的进程。它们主要是 CPU 密集的进程，需要 CPU 的时间比较长。</li></ul></li></ul><h3 id="动态技术" tabindex="-1">动态技术 <a class="header-anchor" href="#动态技术" aria-hidden="true">#</a></h3><p>简单平均法：</p><p>在简单平均法中，有给定的 n 个进程列表 P (i).......P (n)。让 T (i) 表示进程 P (i) 的突发时间。让 τ(n) 表示第 n 个进程的预测突发时间。然后根据简单的平均法，进程 n+1 的预测突发时间将被计算为： <code>τ(n+1)=(1/n)∑T(i)</code> 。其中， <code>0&lt;=i&lt;=n</code> ， <code>∑T(i)</code> 是到目前为止所有进程的实际突发时间的总和。</p><p>指数平均法或老化法：</p><p>Tn 是第 n 个进程的实际爆发时间，τ(n) 是第 n 个进程的预测爆发时间，那么下一个进程（n+1）的 CPU 爆发时间将被计算为： <code>τ(n+1) = α.Tn+(1-α).τ(n)</code> ，其中，α 是平滑度。其值在 0 和 1 之间。</p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-16f25ed6 data-v-956c8bb7><div class="edit-info" data-v-956c8bb7><!----><div class="last-updated" data-v-956c8bb7><p class="VPLastUpdated" data-v-956c8bb7 data-v-93aba522>最近更新: <time datatime="2022-10-02T13:07:32.000Z" data-v-93aba522></time></p></div></div><div class="prev-next" data-v-956c8bb7><div class="pager" data-v-956c8bb7><a class="pager-link prev" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B" data-v-956c8bb7><span class="desc" data-v-956c8bb7>Previous page</span><span class="title" data-v-956c8bb7>📃 01-操作系统原理之进程与线程</span></a></div><div class="has-prev pager" data-v-956c8bb7><a class="pager-link next" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" data-v-956c8bb7><span class="desc" data-v-956c8bb7>Next page</span><span class="title" data-v-956c8bb7>📃 03-操作系统原理之调度算法</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-63f8b582 data-v-2ee2d660><div class="container" data-v-2ee2d660><p class="message" data-v-2ee2d660>Released under the MIT License.</p><p class="copyright" data-v-2ee2d660>Copyright © 2022-present, made by Jonsam NG with 💖</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"cs_开始上手.md\":\"9ba32135\",\"cs_操作系统_0-开始阅读.md\":\"8b54bacb\",\"cs_操作系统_00-操作系统原理之概述.md\":\"7d20ac19\",\"cs_操作系统_01-操作系统原理之进程与线程.md\":\"641a8575\",\"cs_操作系统_02-操作系统原理之cpu调度.md\":\"6e73f395\",\"cs_操作系统_03-操作系统原理之调度算法.md\":\"806c24f4\",\"cs_操作系统_04-操作系统原理之进程同步.md\":\"35fc0109\",\"cs_操作系统_05-操作系统原理之死锁.md\":\"45bc938d\",\"cs_网络原理_0-开始阅读.md\":\"53075533\",\"cs_网络原理_00-计算机网络原理之概述.md\":\"18de38c2\",\"cs_网络原理_01-计算机网络原理之物理层.md\":\"dc8d1883\",\"cs_网络原理_02-计算机网络原理之数据链路层.md\":\"508de0b6\",\"cs_网络原理_03-计算机网络原理之网络层.md\":\"a56ed531\",\"cs_网络原理_04-计算机网络原理之传输层.md\":\"84e37562\",\"cs_网络原理_05-计算机网络原理之应用层.md\":\"e39a110d\",\"dsa_开始上手.md\":\"08d59b38\",\"dsa_数据结构_0-开始阅读.md\":\"1e1acd82\",\"dsa_数据结构_00-队列.md\":\"d5515c6b\",\"index.md\":\"b2beca72\",\"关于.md\":\"92102cb2\",\"示例.md\":\"a5626226\"}")</script>
    <script type="module" async src="/assets/app.f6484fa0.js"></script>
    
  </body>
</html>