<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统原理之内存管理</title>
    <meta name="description" content="100 days to enhance your skills on JavaScript.">
    <link rel="stylesheet" href="/assets/style.f4a95605.css">
    <link rel="modulepreload" href="/assets/chunks/virtual_search-data.9e51a2c0.js">
    <link rel="modulepreload" href="/assets/chunks/vue3-pdf-embed.6cac7ab7.js">
    <link rel="modulepreload" href="/assets/chunks/vue3-video-player.common.e8418371.js">
    <link rel="modulepreload" href="/assets/chunks/vue-codemirror.esm.d82da4ad.js">
    <link rel="modulepreload" href="/assets/chunks/index.cfa69757.js">
    <link rel="modulepreload" href="/assets/chunks/gitalk.726bf68e.js">
    <link rel="modulepreload" href="/assets/app.38a51c30.js">
    <link rel="modulepreload" href="/assets/CS_操作系统_06-操作系统原理之内存管理.md.fe078901.lean.js">
    
    <link rel="shortcut icon" href="/logo/favicon.ico" sizes="any">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#579871">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/logo/apple-touch-icon.png">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-63f8b582><!--[--><!--]--><!--[--><span tabindex="-1" data-v-51c7d2ac></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-51c7d2ac> Skip to content </a><!--]--><!----><header class="VPNav" data-v-63f8b582 data-v-8f5cf07d><div class="VPNavBar has-sidebar" data-v-8f5cf07d data-v-122aa4f8><div class="container" data-v-122aa4f8><div class="VPNavBarTitle has-sidebar" data-v-122aa4f8 data-v-da07d203><a class="title" href="/" data-v-da07d203><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo/favicon-16x16.png" alt data-v-982a05c4><!--]--><!--[-->100 days of JavaScript<!--]--><!--[--><!--]--></a></div><div class="content" data-v-122aa4f8><!--[--><!--]--><div class="VPNavBarSearch search" data-v-122aa4f8><!--teleport start--><!--teleport end--><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><span class="DocSearch-Button-Key">Meta</span><span class="DocSearch-Button-Key">K</span></span></button></div></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-122aa4f8 data-v-34c67e9e><span id="main-nav-aria-label" class="visually-hidden" data-v-34c67e9e>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 📂 CS <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" data-v-fae0e578 data-v-4990fafc><!--[-->📃 开始上手<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 操作系统<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 网络原理<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 📂 DSA <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/DSA/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" data-v-fae0e578 data-v-4990fafc><!--[-->📃 开始上手<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/DSA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-fae0e578 data-v-4990fafc><!--[-->📂 数据结构<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> 🗳️ More <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/%E7%A4%BA%E4%BE%8B" data-v-fae0e578 data-v-4990fafc><!--[-->示例<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="/%E5%85%B3%E4%BA%8E" data-v-fae0e578 data-v-4990fafc><!--[-->关于<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-34c67e9e data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d2d759f4><span class="text" data-v-d2d759f4><!----> ⛓️ Links <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-d2d759f4><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><div class="items" data-v-7261a74c><!--[--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://source.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->源码阅读<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://dsa.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->Fancy-DSA<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://ox.jonsam.site" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->氧气空间<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="http://docs.jonsam.site/project-5/" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->深入学习设计模式<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7261a74c data-v-fae0e578><a class="VPLink link" href="https://source.jonsam.site/nav" target="_blank" rel="noreferrer" data-v-fae0e578 data-v-4990fafc><!--[-->导航<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-4990fafc><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="https://www.jonsam.site" target="_blank" rel="noreferrer" data-v-34c67e9e data-v-148177db data-v-4990fafc><!--[-->📮 Blog<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-122aa4f8 data-v-132a39fa><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-132a39fa data-v-23f49a49 data-v-641a7590><span class="check" data-v-641a7590><span class="icon" data-v-641a7590><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-23f49a49><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-23f49a49><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-122aa4f8 data-v-34532fbd data-v-a0d6b759><!--[--><a class="VPSocialLink" href="https://github.com/jonsam-ng/100-day-of-js-enhance" target="_blank" rel="noopener" data-v-a0d6b759 data-v-902601b3><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-122aa4f8 data-v-2388b4fb data-v-d2d759f4><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d2d759f4><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-d2d759f4><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-d2d759f4><div class="VPMenu" data-v-d2d759f4 data-v-7261a74c><!----><!--[--><!--[--><!----><div class="group" data-v-2388b4fb><div class="item appearance" data-v-2388b4fb><p class="label" data-v-2388b4fb>Appearance</p><div class="appearance-action" data-v-2388b4fb><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-2388b4fb data-v-23f49a49 data-v-641a7590><span class="check" data-v-641a7590><span class="icon" data-v-641a7590><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-23f49a49><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-23f49a49><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-2388b4fb><div class="item social-links" data-v-2388b4fb><div class="VPSocialLinks social-links-list" data-v-2388b4fb data-v-a0d6b759><!--[--><a class="VPSocialLink" href="https://github.com/jonsam-ng/100-day-of-js-enhance" target="_blank" rel="noopener" data-v-a0d6b759 data-v-902601b3><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-122aa4f8 data-v-84ae7409><span class="container" data-v-84ae7409><span class="top" data-v-84ae7409></span><span class="middle" data-v-84ae7409></span><span class="bottom" data-v-84ae7409></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-63f8b582 data-v-986ae53f><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-986ae53f><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-986ae53f><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-986ae53f>Menu</span></button><a class="top-link" href="#" data-v-986ae53f> Return to top </a></div><aside class="VPSidebar" data-v-63f8b582 data-v-aeceacfc><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-aeceacfc><span class="visually-hidden" id="sidebar-aria-label" data-v-aeceacfc> Sidebar Navigation </span><!--[--><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 CS</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E5%BC%80%E5%A7%8B%E4%B8%8A%E6%89%8B" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 开始上手</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 操作系统</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 0-开始阅读</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 00-操作系统原理之概述</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 01-操作系统原理之进程与线程</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8BCPU%E8%B0%83%E5%BA%A6" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 02-操作系统原理之CPU调度</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 03-操作系统原理之调度算法</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 04-操作系统原理之进程同步</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AD%BB%E9%94%81" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 05-操作系统原理之死锁</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 06-操作系统原理之内存管理</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-aeceacfc><section class="VPSidebarGroup collapsible" data-v-aeceacfc data-v-991b9bc9><div class="title" role="button" data-v-991b9bc9><h2 class="title-text" data-v-991b9bc9>📂 网络原理</h2><div class="action" data-v-991b9bc9><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-991b9bc9><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-991b9bc9><!--[--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 0-开始阅读</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 00-计算机网络原理之概述</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 01-计算机网络原理之物理层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 02-计算机网络原理之数据链路层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 03-计算机网络原理之网络层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 04-计算机网络原理之传输层</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82" style="padding-left:0px;" data-v-33738aa2 data-v-4990fafc><!--[--><span class="link-text" data-v-33738aa2>📃 05-计算机网络原理之应用层</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-63f8b582 data-v-431161ac><div class="VPDoc has-sidebar has-aside" data-v-431161ac data-v-16f25ed6><div class="container" data-v-16f25ed6><div class="aside" data-v-16f25ed6><div class="aside-curtain" data-v-16f25ed6></div><div class="aside-container" data-v-16f25ed6><div class="aside-content" data-v-16f25ed6><div class="VPDocAside" data-v-16f25ed6 data-v-9822eb1b><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-9822eb1b data-v-12a7ca3a><div class="content" data-v-12a7ca3a><div class="outline-marker" data-v-12a7ca3a></div><div class="outline-title" data-v-12a7ca3a>🔗 内容纲要：</div><nav aria-labelledby="doc-outline-aria-label" data-v-12a7ca3a><span class="visually-hidden" id="doc-outline-aria-label" data-v-12a7ca3a> Table of Contents for current page </span><ul class="root" data-v-12a7ca3a data-v-501ed047><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-9822eb1b></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-16f25ed6><div class="content-container" data-v-16f25ed6><!--[--><!--]--><main class="main" data-v-16f25ed6><div style="position:relative;" class="vp-doc _CS_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" data-v-16f25ed6><div><h1 id="操作系统原理之内存管理" tabindex="-1">操作系统原理之内存管理 <a class="header-anchor" href="#操作系统原理之内存管理" aria-hidden="true">#</a></h1><div class="badge-group" data-v-4ecad2c5><span class="group-tag" data-v-4ecad2c5>标签：</span><!--[--><span class="badge tip" style="vertical-align:middle;" data-v-4ecad2c5 data-v-dd429f7e>操作系统原理</span><!--]--></div><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-hidden="true">#</a></h2><nav class="table-of-contents"><ul><li><a href="#目录">目录</a></li><li><a href="#存储器和存储单元介绍">存储器和存储单元介绍</a></li><li><a href="#存储器层次结构设计及其特点">存储器层次结构设计及其特点</a></li><li><a href="#内存管理中的分区方法">内存管理中的分区方法</a><ul><li><a href="#分区分配方法">分区分配方法</a></li><li><a href="#first-fit">First Fit</a></li><li><a href="#best-fit">Best Fit</a></li><li><a href="#worst-fit">Worst Fit</a></li><li><a href="#next-fit">Next Fit</a></li><li><a href="#最佳匹配最好吗？">最佳匹配最好吗？</a></li></ul></li><li><a href="#连续内存分配">连续内存分配</a><ul><li><a href="#静态分区和动态分区">静态分区和动态分区</a></li><li><a href="#静态分区">静态分区</a></li><li><a href="#动态分区">动态分区</a></li></ul></li><li><a href="#伙伴系统内存分配技术">伙伴系统内存分配技术</a></li><li><a href="#固定（或静态）分区">固定（或静态）分区</a><ul><li><a href="#固定分区（fixed-partitioning）">固定分区（Fixed Partitioning）</a></li><li><a href="#可变（或动态）分区">可变（或动态）分区</a></li></ul></li><li><a href="#非连续内存分配">非连续内存分配</a></li><li><a href="#逻辑地址和物理地址">逻辑地址和物理地址</a><ul><li><a href="#逻辑地址和物理地址的概念">逻辑地址和物理地址的概念</a></li><li><a href="#逻辑和物理地址的区别">逻辑和物理地址的区别</a></li></ul></li><li><a href="#虚拟地址到物理地址的映射">虚拟地址到物理地址的映射</a><ul><li><a href="#mmu（内存管理单元）">MMU（内存管理单元）</a></li><li><a href="#地址绑定（address-binding）">地址绑定（Address binding）</a></li><li><a href="#物理地址的映射">物理地址的映射</a></li></ul></li><li><a href="#操作系统中的分页">操作系统中的分页</a></li></ul></nav><h2 id="存储器和存储单元介绍" tabindex="-1">存储器和存储单元介绍 <a class="header-anchor" href="#存储器和存储单元介绍" aria-hidden="true">#</a></h2><p>内存设备是数字系统（ digital system），可以临时或长期存储数据。从数字计算机到硬盘都有内置的存储设备（memory devices），可以存储用户或制造商的数据。这些数据要么是控制程序的形式，要么是启动系统的程序。因此，为了存储如此大量的数据，内存设备必须有巨大的容量（capacity）。我们面临的挑战是如何建造具有大容量但成本可控的存储设备。存储器设备必须能够存储永久数据（permanent data）和瞬时数据（instantaneous data）。</p><p>存储器（Memories）是由寄存器（registers）组成的。存储器中的每个寄存器就是一个存储位置（storage location）。存储位置也被称为内存位置（memory location）。存储器位置是用地址（Address）来识别的。一个存储器可以存储的总位数就是它的容量（capacity）。</p><p>一个存储元素（storage element）被称为存储单元（Cell）。每个寄存器是由一个存储元素组成的，其中存储着一位数据（bit）。存储器中的数据分别通过称为写（writing）和读（reading）的过程进行存储（stored）和检索（retrieved）。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.37svthnjjw40.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.37svthnjjw40.webp"></p><p>一个字（word）是一组比特（bits），一个存储单元（memory unit）在这里存储二进制信息。一组 8 位（bits）的字被称为一个字节（byte）。一个存储单元由数据线（data lines）、地址选择线（address selection lines）和指定传输方向的控制线（control lines）组成。一个存储单元的如下所示：</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.a9qycnh9gjk.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.a9qycnh9gjk.webp"></p><p>数据线提供要存储在存储器中的信息。控制输入线指定数据的直接传输。k-address 线指定选择的字。当有 k 条地址线时，可以访问 2<sup>k</sup>个内存字。</p><p>以下是一些重要的存储单元 :</p><ul><li>位（Bit，Binary Units）：位是电气状态（electric state）的逻辑表示。它可以是 1 或 0。</li><li>Nibble：它指的是 4 个比特的组。</li><li>字节（Byte）：一个字节是由 8 个比特组成的一组。</li><li>字（Word）：它是一个固定位数的组，它因计算机而异，但对每个设备来说是相同的。计算机以字的形式存储信息。</li></ul><p>以下是存储单元的转换：</p><ul><li>Kilobyte (kb): 1kb = 1024 byte</li><li>Megabyte (mb): 1mb = 1024 kb</li><li>Gigabyte (gb): 1gb = 1024 mb</li><li>Terabyte (tb): 1tb = 1024 gb</li><li>Petabyte (pb): 1pb = 1024 tb</li></ul><p>参考：</p><ul><li><a href="https://www.geeksforgeeks.org/random-access-memory-ram-and-read-only-memory-rom/" target="_blank" rel="noreferrer">Random Access Memory (RAM) and Read Only Memory (ROM) - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/different-types-ram-random-access-memory/" target="_blank" rel="noreferrer">Different Types of RAM (Random Access Memory ) - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/cache-memory/" target="_blank" rel="noreferrer">Cache Memory - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/secondary-memory/" target="_blank" rel="noreferrer">Secondary Memory - GeeksforGeeks</a></li></ul><h2 id="存储器层次结构设计及其特点" tabindex="-1">存储器层次结构设计及其特点 <a class="header-anchor" href="#存储器层次结构设计及其特点" aria-hidden="true">#</a></h2><p>在计算机系统设计（Computer System Design）中，内存层次（Memory Hierarchy）是对内存组织的一种改进，它可以使访问时间（access time）最小化。存储器层次结构是基于一种被称为参考定位（locality of references）的程序行为而开发的。下图清楚地展示了存储器层次结构的不同级别。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1cd94z9wiyhs.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1cd94z9wiyhs.webp"></p><p>这种内存层次结构设计主要分为 2 种类型：</p><ul><li>外部存储器或二级存储器（External Memory or Secondary Memory）：包括磁盘（Magnetic Disk）、光盘（Optical Disk）、磁带（Magnetic Tape），即处理器通过 I/O 模块（I/O Module）访问的外围存储设备（peripheral storage devices）。</li><li>内部存储器或主存储器（Internal Memory or Primary Memory）：由主存储器（Main Memory）、缓存存储器（Cache Memory）和 CPU 寄存器组成（CPU registers）。这是由处理器直接访问的。</li></ul><p>我们可以从上图中推断出存储器层次结构设计的以下特点：</p><ul><li>容量（Capacity）。它是内存可以存储的总体信息量（global volume of information）。当我们在层次结构中从上到下移动时，容量会增加。</li><li>访问时间（Access Time）。它是读 / 写请求（read/write request）和数据可用性（availability of the data）之间的时间间隔。随着我们在层次结构中从上到下的移动，访问时间会增加。</li><li>性能（Performance）。早些时候，当计算机系统在设计时没有采用内存层次结构，由于访问时间的巨大差异，CPU 寄存器和主内存之间的速度差距增加。这导致了系统性能的降低，因此需要加强。这种改进是以内存层次设计（Memory Hierarchy Design）的形式进行的，因为它提高了系统的性能。<strong>提高系统性能的最重要的方法之一是最大限度地减少操作数据所需的内存层次的深度</strong>。</li><li>单位成本（Cost per bit）。当我们在层次结构中从下往上移动时，单位成本就会增加，即内部存储器比外部存储器成本高。</li></ul><h2 id="内存管理中的分区方法" tabindex="-1">内存管理中的分区方法 <a class="header-anchor" href="#内存管理中的分区方法" aria-hidden="true">#</a></h2><p>在操作系统中，以下是四种常见的内存管理技术（memory management techniques）：</p><ul><li>单一连续分配（Single contiguous allocation）。MS-DOS 使用的最简单的一种分配方法。所有的内存（除了一些为操作系统保留的内存）都可以供一个进程使用。</li><li>分区式分配（Partitioned allocation）。内存被划分为不同的块或分区（blocks or partitions）。每个进程根据需求被分配。</li><li>分页内存管理（Paged memory management）。内存被分为固定大小的单元（units），称为页帧（page frames），在虚拟内存环境（virtual memory environment）中使用。</li><li>分段式内存管理（Segmented memory management）。内存被划分为不同的段（段（segments）是进程数据或代码的逻辑分组）。在这种管理中，分配的内存不一定是连续的。</li></ul><p>大多数操作系统（例如 Windows 和 Linux）使用分段分页（Segmentation with Paging）的方式。一个进程被划分为若干段，每个段都有页。</p><h3 id="分区分配方法" tabindex="-1">分区分配方法 <a class="header-anchor" href="#分区分配方法" aria-hidden="true">#</a></h3><p>在分区分配（Partition Allocation）中，当有一个以上的分区可以自由地满足一个进程的要求时，必须选择一个分区。为了选择一个特定的分区，需要一种<strong>分区分配方法</strong>（partition allocation method）。如果一种分区分配方法能够<strong>避免内部碎片</strong>（internal fragmentation），则被认为是更好的。</p><p>当需要将一个进程加载到主内存时，如果有超过一个足够大的空闲内存块，那么操作系统就会决定分配哪个空闲块。有不同的放置算法（Placement Algorithm）。</p><ul><li>First Fit：首项匹配</li><li>Best Fit：最佳匹配</li><li>Worst Fit：最差匹配</li><li>Next Fit：尾项匹配</li></ul><div class="tip custom-block"><p class="custom-block-title">内存碎片</p><p>内部碎片与外部碎片：</p><ul><li>内部碎片（Internal Fragmentation）: 当把分区分配给一个进程后，分区内的空间有剩余时就会发生。这个空间被称为内部碎片化的空间，它不能被分配给任何其他进程。这是因为静态分区只允许在每个分区中存储一个进程。内部碎片只发生在静态分区中。</li><li>外部碎片（External Fragmentation）：当主存中有存储进程所需的空的空间总量（the total amount of empty space）时，就会发生这种情况。但由于空间不连续，所以进程不能被存储。</li></ul></div><h3 id="first-fit" tabindex="-1">First Fit <a class="header-anchor" href="#first-fit" aria-hidden="true">#</a></h3><p>在 First Fit 算法中，分配的分区是来自主内存顶部的<strong>第一个</strong>足够大的块。它从头开始扫描内存并选择第一个足够大的可用块。因此，它分配了第一个足够大的洞（hole）。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6hwd1zb1fp40.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6hwd1zb1fp40.webp"></p><h3 id="best-fit" tabindex="-1">Best Fit <a class="header-anchor" href="#best-fit" aria-hidden="true">#</a></h3><p>将进程分配到空闲可用分区中第一个最小的充分分区（first smallest sufficient partition）。它搜索整个洞的列表，以找到最小的洞，其大小大于或等于进程的大小。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.10n8jb3firsw.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.10n8jb3firsw.webp"></p><h3 id="worst-fit" tabindex="-1">Worst Fit <a class="header-anchor" href="#worst-fit" aria-hidden="true">#</a></h3><p>将进程分配到主内存中可自由使用的分区中最大的足够的分区（largest sufficient）。它与最佳匹配算法相反。它搜索整个洞的列表，以找到最大的洞并将其分配给进程。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6u721m64sho0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6u721m64sho0.webp"></p><h3 id="next-fit" tabindex="-1">Next Fit <a class="header-anchor" href="#next-fit" aria-hidden="true">#</a></h3><p>Next Fit 与 First Fit 类似，但它将从最后一个分配点搜索第一个足够的分区。</p><h3 id="最佳匹配最好吗？" tabindex="-1">最佳匹配最好吗？ <a class="header-anchor" href="#最佳匹配最好吗？" aria-hidden="true">#</a></h3><p>尽管最佳匹配使浪费的空间最小化，但它消耗了大量的处理器时间来搜索接近所需尺寸的块。另外，在某些情况下，Best-fit 的表现可能比其他算法要差。</p><h2 id="连续内存分配" tabindex="-1">连续内存分配 <a class="header-anchor" href="#连续内存分配" aria-hidden="true">#</a></h2><p>连续内存分配（Contiguous memory allocation）是一种内存分配技术。它只允许以一种连续的方式存储进程数据和代码。因此，整个进程必须作为一个单一的实体存储在内存的一个地方。</p><h3 id="静态分区和动态分区" tabindex="-1">静态分区和动态分区 <a class="header-anchor" href="#静态分区和动态分区" aria-hidden="true">#</a></h3><p>有两种流行的技术用于连续的内存分配：静态分区、动态分区。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1amq91jruuu8.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1amq91jruuu8.webp"></p><h3 id="静态分区" tabindex="-1">静态分区 <a class="header-anchor" href="#静态分区" aria-hidden="true">#</a></h3><p>静态分区（Static partitioning）是一种固定大小（fixed size）的分区方案。在这种技术中，主内存被预先划分为固定大小的分区。每个分区的大小是固定的，不能被改变。每个分区只允许存储一个进程。</p><p>示例：</p><p>在固定大小的分区方案下，一个大小为 10KB 的内存可以被划分为固定大小的分区，即：</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4glq2mu4tfu0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4glq2mu4tfu0.webp"></p><p>这些分区在进程到达时被分配给它们，分配给到达的进程的分区取决于所采用的算法。</p><p>优势：</p><ul><li>它简单而容易实现。</li><li>它支持多程序设计（multiprogramming），因为多个进程可以存储在主内存中。</li><li>只需要一次内存访问，减少了访问时间。</li></ul><p>缺点：</p><ul><li>它同时受到内部碎片和外部碎片的影响。</li><li>它对内存的利用效率很低。</li><li>多重编程的程度受到限制，与分区的数量相等。</li><li>对进程的大小有限制，因为规模大于最大分区规模的进程不能被存储和执行。</li></ul><h3 id="动态分区" tabindex="-1">动态分区 <a class="header-anchor" href="#动态分区" aria-hidden="true">#</a></h3><p>动态分区（Dynamic Partitioning）是一种可变大小的（variable size）分区方案。它以动态的方式进行分配。当一个进程到达时，一个大小等于进程大小的分区被创建。然后，该分区被分配给该进程。</p><p>优势：</p><ul><li>它不会受到内部碎片的影响。</li><li>多重编程的程度（Degree of multiprogramming）是动态的。</li><li>对进程的大小没有限制。</li></ul><p>缺点：</p><ul><li>它受到外部碎片的影响。</li><li>内存的分配和取消分配很复杂。</li></ul><h2 id="伙伴系统内存分配技术" tabindex="-1">伙伴系统内存分配技术 <a class="header-anchor" href="#伙伴系统内存分配技术" aria-hidden="true">#</a></h2><p>静态分区（Static partition）方案存在着活动进程数量固定的限制，而且空间的使用也可能不是最佳的。伙伴系统（buddy system）是一种内存分配和管理算法，它以二次增量幂（power of two increments）来管理内存。假设内存大小为 2<sup>U</sup>，假设需要一个大小为 S 的内存。</p><ul><li>如果<strong>2<sup>U-1</sup>&lt;S&lt;=2<sup>U</sup></strong>（最大容量）：分配整个区块。</li><li>否则，递归地平均分配区块（不断除以 2），每次都测试此条件，当条件满足时，分配区块并退出循环。</li></ul><p>系统还保留了所有未分配块的记录，可以将这些不同大小的块合并成一个大块。</p><p>优点：</p><ul><li>容易实现</li><li>分配正确大小的区块</li><li>很容易合并相邻的洞（holes）</li><li>分配内存和取消分配内存的速度快</li></ul><p>缺点：</p><ul><li>它要求所有的分配单元都是 2 的幂。</li><li>它导致了内部碎片化</li></ul><p>例子：考虑一个有物理地址空间为 128KB 的 buddy system，计算 18KB 进程的分区大小。因此，18KB 进程的分区大小 = 32KB。它除以 2，直到可能得到适合 18KB 的最小块。</p><h2 id="固定（或静态）分区" tabindex="-1">固定（或静态）分区 <a class="header-anchor" href="#固定（或静态）分区" aria-hidden="true">#</a></h2><p>在操作系统中，内存管理（Memory Management）是负责分配和管理计算机主内存（main memory）的功能。内存管理功能跟踪每个内存位置的状态，无论是分配还是释放，以确保有效和高效地使用主内存（Primary Memory）。</p><p>有两种内存管理技术：连续分配和非连续分配。在连续分配技术中，执行进程必须完全加载在主内存中。连续分配技术可以分为：</p><ul><li>固定（或静态）分区（Fixed (or static) partitioning）</li><li>可变（或动态）分区（Variable (or dynamic) partitioning）</li></ul><h3 id="固定分区（fixed-partitioning）" tabindex="-1">固定分区（Fixed Partitioning） <a class="header-anchor" href="#固定分区（fixed-partitioning）" aria-hidden="true">#</a></h3><p>这是最古老和最简单的技术，用于在主内存中放置一个以上的进程。在这种分区中，RAM 中的分区（非重叠，non-overlapping）数量是固定的，但每个分区的大小可能是相同的，也可能是不相同的。由于它是一个连续的分配（contiguous allocation），因此不允许跨区（spanning）。这里的分区是在进程执行之前或在系统配置期间进行的。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6phzsd2b0co0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6phzsd2b0co0.webp"></p><p>如上图所示，第一个进程只消耗了主内存 4MB 中的 1MB。因此，第一个区块的内部碎片是 <code>(4-1) = 3MB</code> 。每个区块的内部碎片总和 = <code>(4-1)+(8-7)+(8-7)+(16-14)= 3+1+1+2 = 7MB</code> 。</p><p>假设大小为 7MB 的进程 P5 到来。但是，尽管有可用的自由空间，但由于连续分配（因为不允许跨区），这个进程不能被容纳。因此，7MB 成为外部碎片（External Fragmentation）的一部分。</p><p>固定分区的优点：</p><ul><li>易于实现。实现固定分区所需的算法很容易实现。它只需要将一个进程放入某个分区，而不需要关注内部和外部碎片的出现。</li><li>很少的操作系统开销（Little OS overhead）。固定分区的处理需要较少的多余和间接计算能力。</li></ul><p>固定分区的缺点：</p><ul><li>内部碎片化。主内存的使用效率很低。任何程序，无论多么小，都会占据整个分区。这可能导致内部碎片化。</li><li>外部碎片化。各个分区未使用的总空间（如上所述）不能用于加载进程，即使有可用的空间，但不是以连续的形式加载（因为不允许跨区）。</li><li>限制进程大小。大于主存储器中的分区大小的进程不能被容纳。分区的大小不能根据进入的进程大小而变化。因此，上述例子中 32MB 的进程大小是无效的。</li><li>对多程序化程度的限制（Limitation on Degree of Multiprogramming）。主内存（Main Memory）中的分区是在执行前或在系统配置时进行的。主内存被划分为固定数量的分区。假设 RAM 中存在 n1 个分区，并且进程的数量为 n2，那么就必须满足条件 n2&lt;=n1。在固定分区中，进程的数量大于 RAM 中的分区数量是无效的。</li></ul><h3 id="可变（或动态）分区" tabindex="-1">可变（或动态）分区 <a class="header-anchor" href="#可变（或动态）分区" aria-hidden="true">#</a></h3><p>它是连续分配技术（Contiguous allocation technique）的一部分。它被用来缓解固定分区所面临的问题。与固定分区相比，分区不是在执行前或在系统配置期间进行的。与可变分区有关的各种特征如下：</p><ul><li>最初 RAM 是空的，在运行期间（run-time）根据进程的需要进行分区，而不是在系统配置期间进行分区。</li><li>分区的大小将与进入的进程的大小相等。</li><li>分区的大小根据进程的需要而变化，这样就可以避免内部碎片，以确保有效地利用 RAM。</li><li>RAM 中的分区数量不是固定的，取决于进入的进程数量和主内存的大小。</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.5wti0q34e3g0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.5wti0q34e3g0.webp"></p><p>与固定分区相比，可变分区有一些优点和缺点，如下所述。</p><p>可变分区的优点：</p><ul><li>没有内部碎片（No Internal Fragmentation）。在可变分区中，主内存的空间是严格按照进程的需要分配的，因此不存在内部碎片化的情况。分区中不会有未使用的空间。</li><li>对多程序化的程度没有限制（No restriction on Degree of Multiprogramming）。由于没有内部碎片化，可以容纳更多的进程。一个进程可以被加载，直到内存被用完。</li><li>对进程的大小没有限制（No Limitation on the size of the process）。在固定分区中，如果进程的大小大于最大分区的大小，就不能被加载，而且进程不能被分割，因为在连续分配技术中这是无效的。在可变分区中，进程的大小不能被限制，因为分区的大小是根据进程的大小决定的。</li></ul><p>可变分区的缺点：</p><ul><li>实现困难（Difficult Implementation）。与固定分区相比，实施可变分区是很困难的，因为它涉及到在运行时而不是在系统配置时分配内存。</li><li>外部碎片化（External Fragmentation）。尽管没有内部碎片，也会有外部碎片。例如，假设在上面的例子中，进程 P1（2MB）和进程 P3（1MB）完成了它们的执行。因此，剩下两个空间，即 2MB 和 1MB。让我们假设大小为 3MB 的进程 P5 到来。内存中的空位不能被分配，因为在连续分配中不允许有跨区。规则规定，进程必须在主内存中连续储存才能被执行。因此，这导致了外部碎片化。</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4d6ck4axqr60.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4d6ck4axqr60.webp"></p><p>现在，尽管有必要的可用空间，但 3MB 大小的 P5 不能被容纳，因为在连续的情况下不允许跨区。</p><h2 id="非连续内存分配" tabindex="-1">非连续内存分配 <a class="header-anchor" href="#非连续内存分配" aria-hidden="true">#</a></h2><p>分页（Paging）和分段（Segmentation）是允许一个进程的物理地址空间不连续（non-contiguous）的两种方式。它的优点是减少了内存的浪费，但它增加了由于地址转换（address translation）而产生的开销。由于在地址转换中消耗了时间，它减慢了内存的执行速度。</p><p>在非连续分配（non-contiguous allocation）中，操作系统需要为每个进程维护一个叫做 &quot;页表&quot;（Page Table）的表格，其中包含了进程在内存空间中获得的每个块的基本地址（base address）。在非连续的内存分配中，一个进程的不同部分被分配到主内存的不同地方。允许跨区（Spanning），这在其他技术中是不可能的，如动态或静态连续内存分配。这就是为什么需要分页来确保有效的内存分配。分页是为了消除外部碎片（External Fragmentation）。</p><p>在操作系统中，有五种非连续的内存分配方式：</p><ul><li>分页（Paging）</li><li>多级分页（Multilevel Paging）</li><li>倒置分页（Inverted Paging）</li><li>分段式（Segmentation）</li><li>分段分页（Segmented Paging）</li></ul><p>工作原理：</p><p>一个进程可以以非连续的方式（non-consecutive manner）跨越主存储器中的不同空间。假设进程 P 的大小为 4KB。考虑到主存储器有两个空位（slots），每个空位的大小为 2KB。因此，总的自由空间是 2*2=4KB。在连续的内存分配中，进程 P 不能被容纳，因为不允许跨区。</p><p>在连续分配中，内存中的空间应该被分配给整个进程。如果没有，那么这个空间就无法被分配。但是在非连续分配中，进程可以被分成不同的部分，从而填充主内存中的空间。在这个例子中，进程 P 可以被分成两个大小相同的部分 --2KB。因此，进程 P 的一部分可以被分配到主内存的第一个 2KB 空间，进程的另一部分可以被分配到主内存的第二个 2KB 空间。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.56ap0v2k84w0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.56ap0v2k84w0.webp"></p><p>但是，我们以何种方式划分进程以将其分配到主内存中是非常重要的。进程是在分析了主内存中的空位（empty spaces）数量和它们的大小之后划分的。然后我们才对进程进行划分。这是一个非常耗时的过程。由于主内存中已经存在的进程的执行，空位的数量和大小每次都在变化。</p><p>为了避免这个耗时的过程，我们在到达主内存执行之前，提前在二级内存（secondary memory）中划分我们的进程。每个进程都被划分为大小相同的不同部分，称为页（Pages）。我们也将主内存划分为大小相等的不同部分，称为帧（Frames）。其中：<strong>进程中的页大小 = 内存中帧的大小</strong>。</p><p>尽管它们的数字可能不同。下面的图表将使你更好地理解它：考虑空的主内存，每一帧的大小为 2KB，两个进程 P1 和 P2 各为 2KB。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4rwrvons7ci0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4rwrvons7ci0.webp"></p><p>分页允许一个进程的内存地址空间不连续。分页更加灵活，因为只有进程的页面被移动。与连续的内存分配相比，它允许更多的进程驻留（reside）在主内存中。</p><h2 id="逻辑地址和物理地址" tabindex="-1">逻辑地址和物理地址 <a class="header-anchor" href="#逻辑地址和物理地址" aria-hidden="true">#</a></h2><h3 id="逻辑地址和物理地址的概念" tabindex="-1">逻辑地址和物理地址的概念 <a class="header-anchor" href="#逻辑地址和物理地址的概念" aria-hidden="true">#</a></h3><p>逻辑地址（Logical Address）是由 CPU 在程序运行时产生的。逻辑地址是<strong>虚拟地址</strong>，因为它在物理上不存在，所以它也被称为虚拟地址（Virtual Address）。这个地址被 CPU 用来作为访问物理内存位置（physical memory location）的参考。术语 &quot;逻辑地址空间&quot;（Logical Address Space）是指由一个程序的视角产生的所有逻辑地址的集合。</p><p>内存管理单元（Memory-Management Unit）的硬件设备用于将逻辑地址映射到其相应的物理地址。</p><p>物理地址（Physical Address）确定了所需数据在内存中的物理位置。用户从不直接处理物理地址，但可以通过其相应的逻辑地址进行访问。用户程序产生逻辑地址并认为程序在这个逻辑地址中运行，但程序的执行需要物理内存，因此，逻辑地址在使用前必须由 MMU 映射到物理地址。物理地址空间（Physical Address Space）这一术语用于与逻辑地址空间中的逻辑地址相对应的所有物理地址。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.7016fyu1vdc0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.7016fyu1vdc0.webp"></p><h3 id="逻辑和物理地址的区别" tabindex="-1">逻辑和物理地址的区别 <a class="header-anchor" href="#逻辑和物理地址的区别" aria-hidden="true">#</a></h3><p>逻辑地址和物理地址的基本区别是：</p><ul><li>逻辑地址是由 CPU 从程序的角度产生的，而物理地址是存在于内存单元（memory unit）中的一个位置。</li><li>逻辑地址空间是 CPU 为程序生成的所有逻辑地址的集合，而映射到相应逻辑地址的所有物理地址的集合被称为物理地址空间。</li><li>逻辑地址在内存中并不存在，而物理地址是内存中可以被物理访问的位置。</li><li>相同的逻辑地址是由编译时（Compile-time）和加载时（Load time）的地址绑定方法（address binding）产生的，而在运行时（run-time）的地址绑定方法中它们是不同的。详情请参考这个。</li><li>逻辑地址是由 CPU 在程序运行时产生的，而物理地址是由内存管理单元（MMU）计算的。</li></ul><p>比较表：</p><table><thead><tr><th>参数</th><th>LOGICAL ADDRESS</th><th>PHYSICAL ADDRESS</th></tr></thead><tbody><tr><td>概念</td><td>由 CPU 产生</td><td>存储单元的位置的地址</td></tr><tr><td>地址空间</td><td>逻辑地址空间是由 CPU 生成的与程序有关的所有逻辑地址的集合。</td><td>物理地址空间是映射到相应逻辑地址的所有物理地址的集合。</td></tr><tr><td>可见性</td><td>用户可以查看程序的逻辑地址。</td><td>用户永远无法查看程序的物理地址。</td></tr><tr><td>产生</td><td>由 CPU 生成</td><td>由 MMU 计算</td></tr><tr><td>访问</td><td>用户可以使用逻辑地址来访问物理地址。</td><td>用户可以间接访问物理地址，但不能直接访问。</td></tr><tr><td>可编辑</td><td>逻辑地址可以改变</td><td>物理地址不会改变。</td></tr><tr><td>别名</td><td>也叫虚拟地址（virtual address）。</td><td>真实地址（real address）。</td></tr></tbody></table><h2 id="虚拟地址到物理地址的映射" tabindex="-1">虚拟地址到物理地址的映射 <a class="header-anchor" href="#虚拟地址到物理地址的映射" aria-hidden="true">#</a></h2><p>内存分配技术：</p><p>为了存储数据和管理进程，我们需要一个大尺寸的内存，同时，我们需要尽可能快地访问数据。但是，如果我们增加内存的大小，访问时间也会增加，正如我们所知，CPU 总是为二级内存（secondary memory）生成地址，即逻辑地址。但我们想访问主存储器（main memory），所以我们需要将逻辑地址转换为物理地址。</p><p>主内存与用户进程和操作系统都有互动。所以我们需要有效地使用主内存。主内存被划分为不重叠的（non-overlapping）内存区域，称为分区。</p><h3 id="mmu（内存管理单元）" tabindex="-1">MMU（内存管理单元） <a class="header-anchor" href="#mmu（内存管理单元）" aria-hidden="true">#</a></h3><p>虚拟地址和物理地址之间的运行时的映射是由一个称为 MMU 的硬件设备完成的。在内存管理中，操作系统将处理进程并在磁盘（disk）和内存（memory）之间移动进程进行执行。它跟踪可用和已用的内存。</p><p>MMU 模式: <code>CPU → MMU → Memory</code> 。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.7016fyu1vdc0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.7016fyu1vdc0.webp"></p><ul><li>CPU 将产生逻辑地址，例如：346</li><li>MMU 将产生一个重定位寄存器（relocation register）（基础寄存器，base register），例如：14000</li><li>在内存中，物理地址被定位，例如：(346+14000=14346)</li></ul><p>在地址被发送到内存的时候，重定位寄存器中的值被添加到用户进程产生的每个地址中。用户程序永远不会看到真正的物理地址。程序可以创建一个指向 346 位置的指针，将其存储在内存中，对其进行操作，并与其他地址进行比较。用户程序只产生逻辑地址。然而，这些逻辑地址在使用前必须被映射到物理地址。</p><h3 id="地址绑定（address-binding）" tabindex="-1">地址绑定（Address binding） <a class="header-anchor" href="#地址绑定（address-binding）" aria-hidden="true">#</a></h3><p>地址绑定（Address binding）是指从一个地址空间映射到另一个地址空间的过程。逻辑地址是 CPU 在执行过程中产生的地址，而物理地址是指内存单元（memory unit）中的位置（被加载到内存中的位置）。逻辑地址要经过 MMU 或地址转换单元（address translation unit）的特别转换。这个过程的输出是确切的物理地址或 RAM 中的代码 / 数据的位置。</p><p>地址绑定可以通过三种不同的方式完成：</p><ul><li><p>编译时（Compile Time）：在编译时进程将驻留在内存中，那么就会产生一个绝对地址，即物理地址在编译时被嵌入到程序的可执行文件中。将可执行文件作为一个进程加载到内存中是非常快的。但是，如果生成的地址空间被其他进程占据，那么程序就会崩溃，这就需要重新编译程序以改变地址空间。</p></li><li><p>加载时（Load time）：如果在编译时不知道进程将位于何处，那么将生成一个可重定位的地址（relocatable address）。装载器（loader）将可重定位的地址转换为绝对地址。进程在主内存中的基地址（base address）被加载器加到所有的逻辑地址上，以产生一个绝对地址。在此，如果进程的基址发生变化，那么我们需要再次重新加载进程。</p></li><li><p>执行时（Execution time）：指令在内存中，由 CPU 处理。这时可能会分配和 / 或取消分配额外的内存。如果一个进程在执行过程中可以从一个内存移动到另一个内存（动态链接（dynamic linking）-- 在加载或运行时进行链接），就可以使用这个方法。 例如 Compaction。</p></li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1qz8y4hodqn4.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1qz8y4hodqn4.webp"></p><h3 id="物理地址的映射" tabindex="-1">物理地址的映射 <a class="header-anchor" href="#物理地址的映射" aria-hidden="true">#</a></h3><p>在连续内存分配中，从虚拟地址到物理地址的映射并不是一项困难的任务，因为如果我们从二级内存中取出一个进程并将其复制到主内存中，地址将以连续的方式存储，所以如果我们知道该进程的基本地址，我们可以找出下一个地址。</p><p>内存管理单元是由 2 个寄存器组合而成：</p><ul><li>基址寄存器（Base Register）（重新定位寄存器，Relocation Register）。包含进程的起始物理地址。</li><li>限制寄存器（Limit Register）。指出相对于进程所占区域的基本地址的限制。</li></ul><p>CPU 产生的逻辑地址首先由限制寄存器（limit register）检查，如果产生的逻辑地址值小于限制寄存器的值，存储在重定位寄存器中的基址被加到逻辑地址中，得到内存位置的物理地址。如果逻辑地址的值大于限制寄存器的值，那么 CPU 就会向操作系统发出陷阱（traps），操作系统通过给出致命的错误来终止程序。</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.241bd5q2gn5s.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.241bd5q2gn5s.webp"></p><p>在非连续内存分配中，进程可以被分配到可用空间的任何地方。非连续内存分配中的地址转换是困难的。有几种技术用于非连续内存分配中的地址转换，如分页、多级分页、倒置分页、分段、分段分页（Paging, Multilevel paging, Inverted paging, Segmentation, Segmented paging）。在这些技术中需要不同的数据结构和硬件支持，如 TLB。</p><h2 id="操作系统中的分页" tabindex="-1">操作系统中的分页 <a class="header-anchor" href="#操作系统中的分页" aria-hidden="true">#</a></h2><p>分页是一种内存管理方案，它消除了对物理内存连续分配的需要。这种方案允许一个进程的物理地址空间是不连续的。</p><ul><li>逻辑地址或虚拟地址（<strong>用比特表示</strong>）。一个由 CPU 生成的地址。</li><li>逻辑地址空间或虚拟地址空间（<strong>以字或字节表示</strong>）。由一个程序产生的所有逻辑地址的集合。</li><li>物理地址（以比特为单位）。存储器单元上实际可用的地址。</li><li>物理地址空间（用字或字节表示）。与逻辑地址相对应的所有物理地址的集合。</li></ul><p>示例：</p><ul><li>如果 Logical Address = 31 bit, 则 Logical Address Space = 2<sup>31</sup> words = 2 G words (1 G = 2<sup>30</sup>)</li><li>如果 Logical Address Space = 128 M words = 2<sup>7</sup> * 2<sup>20</sup> words, 则 Logical Address = log2 (2<sup>27</sup>) = 27 bits</li><li>如果 Physical Address = 22 bit, 则 Physical Address Space = 2<sup>22</sup> words = 4 M words (1 M = 2<sup>20</sup>)</li><li>如果 Physical Address Space = 16 M words = 2<sup>4</sup> * 2<sup>20</sup> words, then Physical Address = log2 (2<sup>24</sup>) = 24 bits</li></ul><p>从虚拟地址到物理地址的映射是由内存管理单元（MMU）完成的，它是一个硬件设备，这种映射被称为<strong>分页技术</strong>（paging technique）。</p><ul><li>物理地址空间在概念上被划分为若干固定大小的块，称为帧（frames）。</li><li>逻辑地址空间也被分割成固定大小的块，称为页（pages）。</li><li>页大小 = 帧大小（Page Size = Frame Size）</li></ul><p>让我们考虑一个例子：</p><ul><li>物理地址 = 12 位，那么物理地址空间 = 4K 字</li><li>逻辑地址 = 13 位，那么逻辑地址空间 = 8K 字</li><li>页大小 = 帧大小 = 1 K 字（假设）</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4j40keoqup00.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4j40keoqup00.webp"></p><p>由 CPU 产生的地址被分为：</p><ul><li>页数 (p，Page number)。表示逻辑地址空间中的页或页号所需的比特数。</li><li>页偏移 (d，Page offset)。表示逻辑地址空间的页中的特定字或页大小或页的字数或页偏移所需的比特数。</li></ul><p>物理地址被划分为：</p><ul><li>帧号 (f，Frame number)。表示物理地址空间的帧或帧号所需的比特数。</li><li>帧偏移 (d，Frame offset)。表示物理地址空间的一帧或一帧大小的特定字或一帧的字数或帧偏移所需的位数。</li></ul><p>页表（page table）的硬件实现可以通过使用专用寄存器来完成。但是，只有在页表很小的情况下，页表的使用才会令人满意。如果页表包含大量的条目，那么我们可以使用 TLB（Translation Look-aside buffer），一个特殊的、小型的、快速查找的<strong>硬件缓存</strong>。</p><ul><li>TLB 是一个可关联的（associative）、高速的存储器（memory）。</li><li>TLB 的每个条目由两部分组成：一个标签和一个值（a tag and a value）。</li><li>当这个存储器被使用时，一个项目被同时（simultaneously）与所有的标签进行比较。如果找到这个项目，则返回相应的值。</li></ul><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.290f6kd71pes.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.290f6kd71pes.webp"></p><p>主内存访问时间（Main memory access time）=m，如果页表被保存在主内存中，有效访问时间（Effective access time） = m (页表) + m (页表中的特定页面)</p><p><img data-zooming src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6muhfal5ack0.webp" alt="image" data-src="https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6muhfal5ack0.webp"></p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-16f25ed6 data-v-956c8bb7><div class="edit-info" data-v-956c8bb7><!----><div class="last-updated" data-v-956c8bb7><p class="VPLastUpdated" data-v-956c8bb7 data-v-93aba522>最近更新: <time datatime="2022-10-03T16:20:03.000Z" data-v-93aba522></time></p></div></div><div class="prev-next" data-v-956c8bb7><div class="pager" data-v-956c8bb7><a class="pager-link prev" href="/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AD%BB%E9%94%81" data-v-956c8bb7><span class="desc" data-v-956c8bb7>Previous page</span><span class="title" data-v-956c8bb7>📃 05-操作系统原理之死锁</span></a></div><div class="has-prev pager" data-v-956c8bb7><a class="pager-link next" href="/CS/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/0-%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB" data-v-956c8bb7><span class="desc" data-v-956c8bb7>Next page</span><span class="title" data-v-956c8bb7>📃 0-开始阅读</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-63f8b582 data-v-2ee2d660><div class="container" data-v-2ee2d660><p class="message" data-v-2ee2d660>Released under the MIT License.</p><p class="copyright" data-v-2ee2d660>Copyright © 2022-present, made by Jonsam NG with 💖</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"cs_开始上手.md\":\"4781952e\",\"cs_操作系统_0-开始阅读.md\":\"ef2eea43\",\"cs_操作系统_00-操作系统原理之概述.md\":\"2775f8c5\",\"cs_操作系统_01-操作系统原理之进程与线程.md\":\"c3070463\",\"cs_操作系统_02-操作系统原理之cpu调度.md\":\"48b9e334\",\"cs_操作系统_03-操作系统原理之调度算法.md\":\"de03aa26\",\"cs_操作系统_04-操作系统原理之进程同步.md\":\"68805b77\",\"cs_操作系统_05-操作系统原理之死锁.md\":\"09776650\",\"cs_操作系统_06-操作系统原理之内存管理.md\":\"fe078901\",\"cs_网络原理_0-开始阅读.md\":\"ed453a9a\",\"cs_网络原理_00-计算机网络原理之概述.md\":\"727dab10\",\"cs_网络原理_01-计算机网络原理之物理层.md\":\"c2b04572\",\"cs_网络原理_02-计算机网络原理之数据链路层.md\":\"f6a43ec9\",\"cs_网络原理_03-计算机网络原理之网络层.md\":\"dd5796b8\",\"cs_网络原理_04-计算机网络原理之传输层.md\":\"b1f17993\",\"cs_网络原理_05-计算机网络原理之应用层.md\":\"bf84fd59\",\"dsa_开始上手.md\":\"6541378e\",\"dsa_数据结构_0-开始阅读.md\":\"61ec94f0\",\"dsa_数据结构_00-队列.md\":\"9975e66c\",\"index.md\":\"2151ff68\",\"关于.md\":\"8a4a145d\",\"示例.md\":\"9ab3cd78\"}")</script>
    <script type="module" async src="/assets/app.38a51c30.js"></script>
    
  </body>
</html>