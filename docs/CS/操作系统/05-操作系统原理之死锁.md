# 操作系统原理之死锁

<Badges :content="[{type: 'tip', text:'操作系统原理'}]" />

## 目录

[[TOC]]

## 死锁的介绍

操作系统中的一个进程以下列方式使用资源：

- 请求一个资源
- 使用该资源
- 释放该资源

<Bilibili id="BV12e4y1r7Z8"/>

死锁是（Deadlock）指一组进程被阻塞的情况，因为每个进程都持有一个资源并等待其他进程以获得的另一个资源。考虑一个例子，当两辆火车在同一条轨道上向对方驶去，而只有一条轨道，一旦它们在碰面，没有一辆火车可以移动。类似的情况也发生在操作系统中，当有两个或更多的进程持有一些资源并等待其他进程持有的资源时。例如，在下图中，进程1持有资源1，并等待由进程2获得的资源2，而进程2正在等待资源1。

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6xsc8ouruts0.webp)

如果以下四个条件同时成立，就会出现死锁（必要条件，Necessary Conditions）：

- 相互排斥（Mutual Exclusion）。两个或多个资源是不可共享（non-shareable）的（每次只有一个进程可以使用）
- 持有并等待（Hold and Wait）：一个进程至少持有一个资源并等待资源。
- 不抢占（No Preemption）。除非进程释放资源，否则不能从该进程中获取资源。
- 循环等待（Circular Wait）：一组进程以循环形式互相等待。

处理死锁的方法：

有三种处理死锁的方法。

- 预防或避免死锁。我们的想法是不要让系统进入死锁状态。我们可以单独放大每个类别，**预防（Prevention）是通过否定上述死锁的必要条件之一来实现的**。
避免（Avoidance）是一种未来主义（futuristic）的性质。通过使用 "避免" 的策略，我们必须做出一个假设。我们需要确保在执行进程之前，所有关于进程所需资源的信息都是我们知道的。我们使用Banker算法（Banker’s algorithm）以避免僵局。

- 死锁检测（detection）和恢复（recovery）。允许死锁发生，一旦发生，就进行抢占（preemption）处理。

- 完全忽略这个问题。如果死锁非常罕见，那么就让它发生并重启系统。这是Windows和UNIX都采取的方法。

参考：

- [Operating Systems: Deadlocks](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/7_Deadlocks.html)

## 死锁检测和避免

如果一个系统没有采用预防死锁或避免死锁的算法，那么就可能出现死锁情况。在这种情况下：

- 应用一种算法来检查系统的状态，以确定死锁是否已经发生。
- 应用一种算法从死锁中恢复。

### 死锁避免算法

死锁避免算法（Deadlock Avoidance Algorithm）/银行家算法（Bankers Algorithm）：

该算法采用了若干次不同的数据结构：

- 可用的（Available）：一个长度为m的向量表示每种类型的可用资源的数量。
- 分配（Allocation）：一个n*m矩阵定义了当前分配给进程的每种类型的资源数量。列代表资源，行代表进程。
- 请求（Request）：一个n*m的矩阵表示每个进程的当前请求。如果request[i][j]等于k，那么进程Pi正在请求Rj类型资源的k个实例。

现在，Bankers算法包括一个安全算法（Safety Algorithm）/死锁检测算法（Deadlock Detection Algorithm）。找出系统是否处于安全状态的算法可以描述如下：

算法的步骤：

- 让`Work`和`Finish`分别为长度为m和n的向量。初始化`Work=Available`。对于`i=0, 1, ...., n-1`，如果`Request(i)=0`，则`Finish[i] = true`；否则，`Finish[i]= false`。
- 找到一个索引i，使其同时 `Finish[i] == false`、`Request(i) <= Work`，如果不存在这样的i，则进入第4步。
- `Work= Work+ Allocation(i)`，`Finish[i]= true`，转到第2步。
- 如果对于某些i`Finish[i]== false`，其中`0<=i<n`，那么系统就处于死锁状态（deadlocked state）。此外，如果`Finish[i]==false`，进程`Pi`就处于死锁状态。

例如：

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.59dyjfd3oxw0.webp)

1. 在此例中, Work = [0, 0, 0] & Finish = [false, false, false, false, false]
2. i=0 被选择当同时满足 Finish[0] = false 和 [0, 0, 0]<=[0, 0, 0] 时。
3. Work =[0, 0, 0]+[0, 1, 0] =>[0, 1, 0] & Finish = [true, false, false, false, false].
4. i=2 被选择当同时满足 Finish[2] = false 和 [0, 0, 0]<=[0, 1, 0] 时。
5. Work =[0, 1, 0]+[3, 0, 3] =>[3, 1, 3] & Finish = [true, false, true, false, false].
6. i=1 被选择当同时满足 Finish[1] = false 和 [2, 0, 2]<=[3, 1, 3]时。
7. Work =[3, 1, 3]+[2, 0, 0] =>[5, 1, 3] & Finish = [true, true, true, false, false].
8. i=3 被选择当同时满足 Finish[3] = false 和 [1, 0, 0]<=[5, 1, 3] 时。
9. Work =[5, 1, 3]+[2, 1, 1] =>[7, 2, 4] & Finish = [true, true, true, true, false].
10. i=4 被选择当同时满足 Finish[4] = false 和 [0, 0, 2]<=[7, 2, 4] 时。
11. Work =[7, 2, 4]+[0, 0, 2] =>[7, 2, 6] & Finish = [true, true, true, true, true].
12. 由于Finish是一个全部为真的向量，这意味着在这个例子中没有死锁。

### 银行家算法

银行家算法（Banker’s algorithm）是一种资源分配（resource allocation）和避免死锁的算法（deadlock avoidance algorithm）。该算法测试安全，模拟所有资源的预定最大可能数量的分配，然后进行 "s-state"检查（an “s-state” check）以测试可能的活动，然后决定是否允许继续分配。

简单地说，它检查任何资源的分配是否会导致死锁，或者将资源分配给一个进程是否安全，如果不安全，则不将资源分配给该进程。确定一个安全序列（safe sequence）（即使只有一个）将确保系统不会进入死锁。

银行家算法通常被用来寻找是否存在安全序列（safe sequence）。但在这里我们将确定安全序列的总数并打印所有的安全序列。

所用的数据结构是：

- Available vector
- Max Matrix
- Allocation Matrix
- Need Matrix

示例：

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.44i7uhaxgm40.webp)
![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.3fepn38ugle0.webp)

```txt
Output: Safe sequences are:
P2--> P4--> P1--> P3
P2--> P4--> P3--> P1
P4--> P2--> P1--> P3
P4--> P2--> P3--> P1

There are total 4 safe-sequences 
```

解释:

Total resources 为 R1 = 10, R2 = 5, R3 = 7， allocated resources 为 R1 = (0+2+3+2 =) 7, R2 = (1+0+0+1 =) 2, R3 = (0+0+2+1 =) 3. 因此, remaining resources 为 R1 = (10 – 7 =) 3, R2 = (5 – 2 =) 3, R3 = (7 – 3 =) 4.

- Remaining available = Total resources – allocated resources
- Remaining need = max – allocated

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.7ambzrakhdg0.webp)

因此，我们可以从P2或P4开始。在银行家算法的第一或第二尝试步骤中，我们无法从P1或P3的可用资源中满足剩余需求。只有四个可能的安全序列为：

```txt
P2--> P4--> P1--> P3 
P2--> P4--> P3--> P1 
P4--> P2--> P1--> P3 
P4--> P2--> P3--> P1
```

实现：

```Python
# Python3 program to print all
# possible safe sequences
# using banker's algorithm

# Total number of process
P = 4

# Total number of resources
R = 3

# Total safe-sequences
total = 0

# Function to check if process
# can be allocated or not
def is_available(process_id, allocated,
    max, need, available):
     
 flag = True

 # Check if all the available resources
 # are less greater than need of process
 for i in range(R):
  if (need[process_id][i] > available[i]):
   flag = False

 return flag

# Print all the safe-sequences
def safe_sequence(marked, allocated,
    max, need, available, safe):
 
 global total, P, R
 
 for i in range(P):
  
  # Check if it is not marked
  # already and can be allocated
  if (not marked[i] and
   is_available(i, allocated, max,
      need, available)):
       
   # mark the process
   marked[i] = True

   # Increase the available
   # by deallocating from process i
   for j in range(R):
    available[j] += allocated[i][j]

   safe.append(i)
   
   # Find safe sequence by taking process i
   safe_sequence(marked, allocated, max,
      need, available, safe)
   safe.pop()

   # unmark the process
   marked[i] = False

   # Decrease the available
   for j in range(R):
    available[j] -= allocated[i][j]
  
 # If a safe-sequence is found, display it
 if (len(safe) == P):
  total += 1
  
  for i in range(P):
   print("P" + str(safe[i] + 1), end = '')
   
   if (i != (P - 1)):
    print("--> ", end = '')
   
  print()

# Driver code 
if __name__=="__main__":
 
 # Allocated matrix of size P*R
 allocated = [ [ 0, 1, 0 ],
    [ 2, 0, 0 ],
    [ 3, 0, 2 ],
    [ 2, 1, 1 ]]

 # max matrix of size P*R
 max = [ [ 7, 5, 3 ],
   [ 3, 2, 2 ],
   [ 9, 0, 2 ],
   [ 2, 2, 2 ] ]

 # Initial total resources
 resources = [ 10, 5, 7 ]

 # Available vector of size R
 available = [0 for i in range(R)]
 
 for i in range(R):
  sum = 0
  
  for j in range(P):
   sum += allocated[j][i]

  available[i] = resources[i] - sum
 

 # Safe vector for displaying a
 # safe-sequence
 safe = []

 # Marked of size P for marking
 # allocated process
 marked = [False for i in range(P)]

 # Need matrix of size P*R
 need = [[0 for j in range(R)]
   for i in range(P)]
 
 for i in range(P):
  for j in range(R):
   need[i][j] = (max[i][j] -
     allocated[i][j])
 
 print("Safe sequences are:")
 
 safe_sequence(marked, allocated, max,
    need, available, safe)
 
 print("\nThere are total " + str(total) +
  " safe-sequences")
```

视频演示：

<Bilibili id="av57430740"/>
<Bilibili id="BV1MT411P7EW"/>

## 死锁检测和恢复

死锁检测（Deadlock Detection）:

在这种情况下，对于死锁检测，我们可以运行一个算法来检查资源分配图（Resource Allocation Graph）中的周期（cycle）。图中存在的循环是死锁的充分条件：

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6xsc8ouruts0.webp)