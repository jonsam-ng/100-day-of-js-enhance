# 操作系统原理之调度算法

<Badges :content="[{type: 'tip', text:'操作系统原理'}]" />

## 目录

[[TOC]]

## FCFS和优先级调度的区别

先到先服务（FCFS）：先到先服务（FCFS）是最简单的算法类型。它是一种非抢占式算法，即进程一旦开始执行就不能被打断。FCFS是在FIFO队列的帮助下实现的。进程按照其到达时间的顺序被放入准备队列。首先到达的进程成为队列的首部，而其他随后到达的进程则被添加到队列的后面。在先到先服务（FCFS）算法中，先到的进程在CPU空闲时被首先送入CPU执行。这种算法的主要缺点是，平均等待时间往往相当长。这也导致了车队效应，设备或CPU的利用率降低，效率下降。

优先级调度算法：优先级调度算法是根据进程的优先级来执行的。每个进程被分配一个优先级，具有最高优先级的进程被首先执行。优先级可以从内部和外部定义。内部优先级由系统决定，取决于所需资源的数量、所需时间等，而外部优先级则基于工作需要的时间或为所做工作分配的权重或进程的重要性。优先级调度可以是抢占式或非抢占式。

请注意：

- 如果两个进程有相同的优先级，那么就用FCFS来打破平局。
- 在抢占式模式下，最高优先级进程的等待时间总是零，而在非抢占式模式下，它可能不是零。

缺点：主要问题是饥饿现象。它可能发生在进程流中，系统一直在执行高优先级的进程，而低优先级的进程从未被执行。解决这个问题的方法是老化。老化是指在一个固定的时间间隔后，逐渐增加系统中等待的进程的优先级，例如每10分钟增加1个。这将确保低优先级的进程也能随着时间的推移缓慢地被执行。

FCFS和优先级调度算法之间的区别如下：

| FCFS                                                 | 优先级调度                                                                         |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------- |
| 它按照进程到达的顺序执行，即先到达的进程先被执行。   | 它根据进程的优先级执行，即按照其优先级的降序执行。具有较高优先级的进程首先被执行。 |
| 它在本质上是非抢占式的                               | 非抢占式或者抢占式的。                                                             |
| 它导致进程的等待时间相当长，因此增加了平均等待时间。 | 不存在响应时间和等待时间的概念。                                                   |
| 它导致了车队效应                                     | 可能会发生低优先级的进程无限期地等待而永远不会被执行。                             |
| 它在任何系统中都是最容易实现的。                     | 它最适合于实时的操作系统。                                                         |
| 它不会受到饥饿的影响。                               | 它受到饥饿的影响。                                                                 |

## 抢占式和非抢占式调度的区别

在CPU调度中，我们有两种类型的调度：

- 抢占式调度（Preemptive Scheduling）。在这种情况下，当一个高优先级的进程进入准备状态时，调度器可以随时抢占一个低优先级的运行进程。当调度来自于以下任何一种情况时，它就是抢占式调度：
  - 当一个进程从运行状态切换到准备状态时（例如，当一个中断发生时）。
  - 当一个进程从等待状态切换到准备状态时（例如，在完成I/O之后）。
- 非抢占式调度。在这种情况下，一旦一个进程进入运行状态，它就不能被抢占，直到它完成了它的分配时间。当调度只在以下情况下发生时，我们说这个调度方案是非抢占式或合作式的。
  - 当一个进程从运行状态切换到等待状态时（例如，由于I/O请求或调用wait()终止一个子进程的结果）。
  - 当一个进程终止时。

让我们看看抢占式调度和非抢占式调度的区别：

| 抢占式调度                                                                                     | 非抢占式调度                                                                      |
| ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| CPU被分配给进程一定的时间。                                                                    | CPU被分配给进程直到它结束执行或切换到等待状态。                                   |
| 这里的执行进程在执行过程中被打断。                                                             | 这里的执行进程在执行过程中不被打断。                                              |
| 它通常将进程从就绪状态切换到运行状态，反之亦然，并保持就绪队列。                               | 它不将进程从运行状态切换到就绪状态。                                              |
| 如果高优先级的进程频繁地到达就绪队列，那么低优先级的进程必须等待很长时间，而且可能不得不饿死。 | 如果CPU被分配给具有较大突发时间的进程，那么具有较小突发时间的进程可能不得不饿死。 |
| 它是相当灵活的，因为重要进程被允许在进入准备队列时访问CPU，无论当前执行的是什么进程。          | 它是刚性的，因为即使一个重要进程进入准备队列，运行CPU的进程也不会受到干扰。       |
| 这是成本关联（cost associative）的，因为它必须保持共享数据的完整性。                           | 这不是成本关联的。                                                                |
| 这种调度会导致更多的上下文切换。                                                               | 与抢占式调度相比，这种调度会导致更少的上下文切换。                                |

不能肯定地说抢占式调度比非抢占式调度更好，反之亦然。这取决于如何调度以使进程的平均等待时间最小化和CPU利用率最大化。

## 中周转时间（TAT）和等待时间（WT）的区别

在CPU调度中，我们经常需要在到达时间、突发时间和完成时间的帮助下找到平均周转时间和等待时间。让我们来简单了解一下它们。

- 周转时间（TAT，Turnaround Time）：它是指从提交进程到完成进程所需的时间间隔。完成时间和到达时间之间的差异被称为周转时间。即`TAT = CT - AT`。
- 完成时间（CT，Completion Time）：这是进程完成其执行的时间。
- 到达时间（AT，Arrival Time）：这是进程到达准备状态的时间。
- 等待时间（WT，Waiting Time）：进程在准备队列中等待获得CPU的时间。Turnaround Time和Burst Time之间的时间差被称为等待时间。即`WT = TAT - BT`。
- 突发时间（BT，Burst Time）：这是进程执行所需的时间。

现在有了等待时间和突发时间，我们还可以通过以下方式计算周转时间：`TAT = BT + WT`。

## LJF和LRJF调度的区别

最长作业优先（LJF）：它是CPU调度算法，具有最大突发时间的进程首先被执行。一旦进程进入准备队列，该进程只有在执行完成后才退出，因此它是一个非抢占式的进程。在进程的突发时间相同的情况下，选择总体时间最低的工作。这种CPU调度算法导致了系统的低吞吐量。

最长剩余作业优先（LRJF）：它是最长作业优先的CPU调度算法的抢占式版本。每秒钟都会选择进程的突发时间最长的工作。如果进程的突发时间相同，则选择总体到达时间较短的工作。由于同时检查进程的剩余Burst Time，所以会出现饥饿现象。这也被称为 "最长剩余时间优先"（Longest Remaining Time First）算法。

LJF和LRJF CPU调度算法的区别:

| LJF                                                      | LRJF                                               |
| -------------------------------------------------------- | -------------------------------------------------- |
| 非抢占式                                                 | 抢占式                                             |
| 它受到饥饿现象影响 它也受到饥饿现象的影响                |
| 等待时间高                                               | 等待时间不高，进程在一定的时间间隔后会有机会执行。 |
| 上下文切换较少，因为进程一旦进入运行状态就会被完全执行。 | 上下文切换较多，因为进程不断地被检查执行。         |
| 进程仅根据其CPU时间和到达时间执行，不会增加CPU的负载。   | 进程反复检查空闲的CPU，从而增加过载。              |
| 在最长的工作执行完成之前，没有进程可以完成执行。         | 进程可以在最长的进程之前完成执行。                 |

## SJF和SRJF调度的区别

最短作业优先（SJF）：最短作业优先（SJF）是一种调度策略，它选择具有最小执行时间的等待进程来执行下一个作业。它也被称为最短作业优先（SJN，Shortest Job Next）或最短进程优先（SPN，Shortest Process Next）。它是一种非抢占式的调度算法。

最短剩余作业优先（SRTF）：最短剩余作业优先（SRJF）是SJF调度的抢占性版本。在这种调度算法中，选择完成前剩余时间最小的进程来执行。具有相同到达时间的进程将把SRTF转换为SJF。

相似性：

- SJF和SRJF实际上都是不可行的，因为不可能预测进程的突发时间。
- SJF和SRJF都可能导致进程饿死，因为如果短的进程不断增加，长的进程可能会被无限期地搁置。
- 一旦所有的进程都在就绪队列中，SJF和SRJF都被认为是相同的。这是因为在进程被添加到就绪队列中后，不会进行抢占。

差异：

| 最短作业优先                                       | 最短剩余作业优先                               |
| -------------------------------------------------- | ---------------------------------------------- |
| 它是一种非抢占式算法。                             | 它是一种抢占式算法。                           |
| 它涉及的开销比SRJF少。                             | 它涉及的开销比SJF多。                          |
| 它的执行速度比SRJF慢。                             | 它的执行速度比SJF快。                          |
| 导致相对较低的吞吐量。                             | 由于执行时间较短，导致吞吐量增加。             |
| 它使每个进程的平均等待时间最小化。                 | 它可能也可能不使每个进程的平均等待时间最小化。 |
| 它可能受到优先级倒置（priority inversion）的影响。 | 它可能受到车队效应的影响。                     |
| 涉及较少的上下文切换次数。                         | 涉及较多的上下文切换次数。                     |
| 先执行短的进程，然后再执行长的进程。               | 短的进程运行快，长的进程响应时间差。           |

## FCFS和SJF调度的区别

先到先服务（FCFS）和最短作业优先（SJF）调度算法的区别如下：

| FCFS                                                                       | SJF                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| FCFS按照进程到达的顺序执行，即先到达的进程先被执行。                       | 最短作业优先（SJF）根据进程的突发时间执行，即按照突发时间的递增顺序执行。   |
| FCFS本质上是非抢占式的                                                     | SJF也是非抢占式的，但它的抢占式版本也被称为最短剩余时间优先（SRTF）算法。   |
| FCFS导致进程的等待时间相当长，因此增加了平均等待时间。                     | 给定进程集的平均等待时间是最小的。                                          |
| FCFS会导致车队效应。                                                       | 它不会导致车队效应。                                                        |
| FCFS算法在任何系统中都是最容易实现的。                                     | SJF的真正困难在于知道下一个CPU请求或突发的时间长度。                        |
| 一个进程可能需要等待相当长的时间才能被执行，这取决于先到的进程的突发时间。 | 一个长的进程可能永远不会被执行，系统可能一直在执行短的进程。                |
| FCFS导致较低的设备和CPU利用率，从而降低了系统的效率。                      | SJF由于较低的平均等待时间，导致了较高的系统效率。                           |
| FCFS导致最小的开销。                                                       | 在SJF的情况下，应该记录经过的时间（elapsed time），导致处理器上的更多开销。 |
| FCFS不存在饥饿问题                                                         | SJF则存在饥饿问题。                                                         |
