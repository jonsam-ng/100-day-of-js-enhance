# 操作系统原理之调度算法

<Badges :content="[{type: 'tip', text:'操作系统原理'}]" />

## 目录

[[TOC]]

## FCFS和优先级调度的区别

先到先服务（FCFS）：先到先服务（FCFS）是最简单的算法类型。它是一种非抢占式算法，即进程一旦开始执行就不能被打断。FCFS是在FIFO队列的帮助下实现的。进程按照其到达时间的顺序被放入准备队列。首先到达的进程成为队列的首部，而其他随后到达的进程则被添加到队列的后面。在先到先服务（FCFS）算法中，先到的进程在CPU空闲时被首先送入CPU执行。这种算法的主要缺点是，平均等待时间往往相当长。这也导致了车队效应，设备或CPU的利用率降低，效率下降。

优先级调度算法：优先级调度算法是根据进程的优先级来执行的。每个进程被分配一个优先级，具有最高优先级的进程被首先执行。优先级可以从内部和外部定义。内部优先级由系统决定，取决于所需资源的数量、所需时间等，而外部优先级则基于工作需要的时间或为所做工作分配的权重或进程的重要性。优先级调度可以是抢占式或非抢占式。

请注意：

- 如果两个进程有相同的优先级，那么就用FCFS来打破平局。
- 在抢占式模式下，最高优先级进程的等待时间总是零，而在非抢占式模式下，它可能不是零。

缺点：主要问题是饥饿现象。它可能发生在进程流中，系统一直在执行高优先级的进程，而低优先级的进程从未被执行。解决这个问题的方法是老化。老化是指在一个固定的时间间隔后，逐渐增加系统中等待的进程的优先级，例如每10分钟增加1个。这将确保低优先级的进程也能随着时间的推移缓慢地被执行。

FCFS和优先级调度算法之间的区别如下：

| FCFS                                                 | 优先级调度                                                                         |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------- |
| 它按照进程到达的顺序执行，即先到达的进程先被执行。   | 它根据进程的优先级执行，即按照其优先级的降序执行。具有较高优先级的进程首先被执行。 |
| 它在本质上是非抢占式的                               | 非抢占式或者抢占式的。                                                             |
| 它导致进程的等待时间相当长，因此增加了平均等待时间。 | 不存在响应时间和等待时间的概念。                                                   |
| 它导致了车队效应                                     | 可能会发生低优先级的进程无限期地等待而永远不会被执行。                             |
| 它在任何系统中都是最容易实现的。                     | 它最适合于实时的操作系统。                                                         |
| 它不会受到饥饿的影响。                               | 它受到饥饿的影响。                                                                 |

## 抢占式和非抢占式调度的区别

在CPU调度中，我们有两种类型的调度：

- 抢占式调度（Preemptive Scheduling）。在这种情况下，当一个高优先级的进程进入准备状态时，调度器可以随时抢占一个低优先级的运行进程。当调度来自于以下任何一种情况时，它就是抢占式调度：
  - 当一个进程从运行状态切换到准备状态时（例如，当一个中断发生时）。
  - 当一个进程从等待状态切换到准备状态时（例如，在完成I/O之后）。
- 非抢占式调度。在这种情况下，一旦一个进程进入运行状态，它就不能被抢占，直到它完成了它的分配时间。当调度只在以下情况下发生时，我们说这个调度方案是非抢占式或合作式的。
  - 当一个进程从运行状态切换到等待状态时（例如，由于I/O请求或调用wait()终止一个子进程的结果）。
  - 当一个进程终止时。

让我们看看抢占式调度和非抢占式调度的区别：

| 抢占式调度                                                                                     | 非抢占式调度                                                                      |
| ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| CPU被分配给进程一定的时间。                                                                    | CPU被分配给进程直到它结束执行或切换到等待状态。                                   |
| 这里的执行进程在执行过程中被打断。                                                             | 这里的执行进程在执行过程中不被打断。                                              |
| 它通常将进程从就绪状态切换到运行状态，反之亦然，并保持就绪队列。                               | 它不将进程从运行状态切换到就绪状态。                                              |
| 如果高优先级的进程频繁地到达就绪队列，那么低优先级的进程必须等待很长时间，而且可能不得不饿死。 | 如果CPU被分配给具有较大突发时间的进程，那么具有较小突发时间的进程可能不得不饿死。 |
| 它是相当灵活的，因为重要进程被允许在进入准备队列时访问CPU，无论当前执行的是什么进程。          | 它是刚性的，因为即使一个重要进程进入准备队列，运行CPU的进程也不会受到干扰。       |
| 这是成本关联（cost associative）的，因为它必须保持共享数据的完整性。                           | 这不是成本关联的。                                                                |
| 这种调度会导致更多的上下文切换。                                                               | 与抢占式调度相比，这种调度会导致更少的上下文切换。                                |

不能肯定地说抢占式调度比非抢占式调度更好，反之亦然。这取决于如何调度以使进程的平均等待时间最小化和CPU利用率最大化。

## 中周转时间（TAT）和等待时间（WT）的区别

在CPU调度中，我们经常需要在到达时间、突发时间和完成时间的帮助下找到平均周转时间和等待时间。让我们来简单了解一下它们。

- 周转时间（TAT，Turnaround Time）：它是指从提交进程到完成进程所需的时间间隔。完成时间和到达时间之间的差异被称为周转时间。即`TAT = CT - AT`。
- 完成时间（CT，Completion Time）：这是进程完成其执行的时间。
- 到达时间（AT，Arrival Time）：这是进程到达准备状态的时间。
- 等待时间（WT，Waiting Time）：进程在准备队列中等待获得CPU的时间。Turnaround Time和Burst Time之间的时间差被称为等待时间。即`WT = TAT - BT`。
- 突发时间（BT，Burst Time）：这是进程执行所需的时间。

现在有了等待时间和突发时间，我们还可以通过以下方式计算周转时间：`TAT = BT + WT`。

## LJF和LRJF调度的区别

最长作业优先（LJF）：它是CPU调度算法，具有最大突发时间的进程首先被执行。一旦进程进入准备队列，该进程只有在执行完成后才退出，因此它是一个非抢占式的进程。在进程的突发时间相同的情况下，选择总体时间最低的工作。这种CPU调度算法导致了系统的低吞吐量。

最长剩余作业优先（LRJF）：它是最长作业优先的CPU调度算法的抢占式版本。每秒钟都会选择进程的突发时间最长的工作。如果进程的突发时间相同，则选择总体到达时间较短的工作。由于同时检查进程的剩余Burst Time，所以会出现饥饿现象。这也被称为 "最长剩余时间优先"（Longest Remaining Time First）算法。

LJF和LRJF CPU调度算法的区别:

| LJF                                                      | LRJF                                               |
| -------------------------------------------------------- | -------------------------------------------------- |
| 非抢占式                                                 | 抢占式                                             |
| 它受到饥饿现象影响                                       | 它也受到饥饿现象的影响                             |
| 等待时间高                                               | 等待时间不高，进程在一定的时间间隔后会有机会执行。 |
| 上下文切换较少，因为进程一旦进入运行状态就会被完全执行。 | 上下文切换较多，因为进程不断地被检查执行。         |
| 进程仅根据其CPU时间和到达时间执行，不会增加CPU的负载。   | 进程反复检查空闲的CPU，从而增加过载。              |
| 在最长的工作执行完成之前，没有进程可以完成执行。         | 进程可以在最长的进程之前完成执行。                 |

## SJF和SRJF调度的区别

最短作业优先（SJF）：最短作业优先（SJF）是一种调度策略，它选择具有最小执行时间的等待进程来执行下一个作业。它也被称为最短作业优先（SJN，Shortest Job Next）或最短进程优先（SPN，Shortest Process Next）。它是一种非抢占式的调度算法。

最短剩余作业优先（SRTF）：最短剩余作业优先（SRJF）是SJF调度的抢占性版本。在这种调度算法中，选择完成前剩余时间最小的进程来执行。具有相同到达时间的进程将把SRTF转换为SJF。

相似性：

- SJF和SRJF实际上都是不可行的，因为不可能预测进程的突发时间。
- SJF和SRJF都可能导致进程饿死，因为如果短的进程不断增加，长的进程可能会被无限期地搁置。
- 一旦所有的进程都在就绪队列中，SJF和SRJF都被认为是相同的。这是因为在进程被添加到就绪队列中后，不会进行抢占。

差异：

| 最短作业优先                                       | 最短剩余作业优先                               |
| -------------------------------------------------- | ---------------------------------------------- |
| 它是一种非抢占式算法。                             | 它是一种抢占式算法。                           |
| 它涉及的开销比SRJF少。                             | 它涉及的开销比SJF多。                          |
| 它的执行速度比SRJF慢。                             | 它的执行速度比SJF快。                          |
| 导致相对较低的吞吐量。                             | 由于执行时间较短，导致吞吐量增加。             |
| 它使每个进程的平均等待时间最小化。                 | 它可能也可能不使每个进程的平均等待时间最小化。 |
| 它可能受到优先级倒置（priority inversion）的影响。 | 它可能受到车队效应的影响。                     |
| 涉及较少的上下文切换次数。                         | 涉及较多的上下文切换次数。                     |
| 先执行短的进程，然后再执行长的进程。               | 短的进程运行快，长的进程响应时间差。           |

## FCFS和SJF调度的区别

先到先服务（FCFS）和最短作业优先（SJF）调度算法的区别如下：

| FCFS                                                                       | SJF                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| FCFS按照进程到达的顺序执行，即先到达的进程先被执行。                       | 最短作业优先（SJF）根据进程的突发时间执行，即按照突发时间的递增顺序执行。   |
| FCFS本质上是非抢占式的                                                     | SJF也是非抢占式的，但它的抢占式版本也被称为最短剩余时间优先（SRTF）算法。   |
| FCFS导致进程的等待时间相当长，因此增加了平均等待时间。                     | 给定进程集的平均等待时间是最小的。                                          |
| FCFS会导致车队效应。                                                       | 它不会导致车队效应。                                                        |
| FCFS算法在任何系统中都是最容易实现的。                                     | SJF的真正困难在于知道下一个CPU请求或突发的时间长度。                        |
| 一个进程可能需要等待相当长的时间才能被执行，这取决于先到的进程的突发时间。 | 一个长的进程可能永远不会被执行，系统可能一直在执行短的进程。                |
| FCFS导致较低的设备和CPU利用率，从而降低了系统的效率。                      | SJF由于较低的平均等待时间，导致了较高的系统效率。                           |
| FCFS导致最小的开销。                                                       | 在SJF的情况下，应该记录经过的时间（elapsed time），导致处理器上的更多开销。 |
| FCFS不存在饥饿问题                                                         | SJF则存在饥饿问题。                                                         |

## 优先级调度和RR调度的区别

优先级调度和Round-Robin（RR）调度算法的区别如下：

| 优先级调度                                                   | 循环调度(RR)                                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------------------------------- |
| 优先级调度根据优先级执行进程，即优先级较高的进程首先被执行。 | Round-Robin（RR）根据定义的时间量来执行进程，即每个进程执行固定的时间量。           |
| 优先级调度可以是抢占式的，也可以是非抢占式的。               | Round-Robin（RR）在本质上是抢占式的。                                               |
| 平均等待时间和平均响应时间事先是未知的。                     | 给定的一组进程的平均等待时间相当小，并取决于时间量子。                              |
| 它很容易实现，最适合于实时操作系统。                         | 在任何系统中实现RR都很容易。                                                        |
| 进程阻塞的问题可以用老化（aging）来解决。                    | 每个进程都被执行，每个用户都觉得他的工作正在完成，因为CPU给每个进程的时间是相等的。 |

## EDF和LST调度的区别

### 最早期限优先（EDF）

在最早期限优先（Earliest Deadline First ）的调度算法中，在每个调度点，具有最短期限的任务被安排执行。它是一种用于实时系统的最佳动态优先级驱动（dynamic priority-driven）的调度算法。它使用任务的优先级来进行调度。在EDF中，任务的优先级是根据绝对最后期限分配（absolute deadline）的。具有最短期限的任务得到最高的优先权。

例子：假设这里有两个进程P1和P2。设P1的周期（period）为p1=50；设P1的处理时间为t1=25。设P2的周期为p2=75；让P2的处理时间为t2=30。

解释:

- P1的最后期限较早，所以P1的优先级高于P2。
- 最初P1运行并完成了25次的执行。
- 25次之后，P2开始执行，直到50次，此时P1能够执行。
- 现在，比较（P1，P2）=（100，75）的期限，P2继续执行。
- P2在时间55完成其处理。
- P1开始执行，直到时间75，此时P2能够执行。
- 现在，再次比较（P1，P2）=（100，150）的期限，P1继续执行。
- 重复上面的步骤。
- 最后在时间150，P1和P2都有相同的最后期限，所以P2将继续执行，直到其处理时间，之后P1开始执行。

### 最小松弛时间（LST）

在最小松弛时间（Least Slack Time）调度算法中，在每个调度点，具有最小松弛（minimum laxity）的任务被首先执行。它也是一种用于实时系统的动态优先级驱动的调度算法。它根据系统中所有任务的松弛时间给它们分配一些优先级。拥有最少松弛时间（宽松度）的任务获得最高的优先权。

例子：

- 进程P1。到达时间=0，持续时间=10，最后期限=33
- 进程P2。到达时间=4，持续时间=3，最后期限=28
- 进程P3。到达时间=5，持续时间=10，最后期限=29

解释:

- 在时间t=0时：只有进程P1已经到达。P1被执行到时间t=4。
- 在时间t=4时：P2已经到达。P1的松弛时间：33-4-6=23；P2的松弛时间：28-4-3=21。因此P2开始执行，直到时间t=5时P3到达。
- 在时间t=5时：P1的松弛时间：33-5-6=22；P2的松弛时间：28-5-2=21；P3的松弛时间：29-5-10=12。因此P3开始执行，直到时间t=13
- 在时间t=13时：P1的松弛时间：33-13-6=14；P2的松弛时间：28-13-2=13；P3的松弛时间：29-13-2=14。因此，P2开始执行，直到时间t=15
- 在时间t=15时：P1的松弛时间：33-15-6=12；P3的松弛时间：29-15-2=12；因此P3开始执行，直到时间t=16。
- 在时间t=16时：P1的松弛时间：33-16-6=11；P3的松弛时间：29-16-=12。因此，P1开始执行，直到时间t=18，以此类推。

EDF和LST调度算法的区别:

| EDF                                          | LST                                    |
| -------------------------------------------- | -------------------------------------- |
| 具有最短期限的任务被安排在第一位。           | 具有最小松弛时间的任务被安排在第一位。 |
| 它根据任务的最后期限分配任务的优先级         | 根据任务的松弛时间分配任务。           |
| 它既可以作为静态调度也可以作为动态调度使用。 | 它只被用作动态调度。                   |
| 不需要任务的执行时间。                       | 它需要任务的执行时间。                 |
| 它是一个简单和最优的算法。                   | 它是一个复杂的算法。                   |
| 它可以在任何任务集（set of tasks）上实施。   | 它只能在有突发时间的任务集上实施。     |
| 它完全利用了CPU（有时甚至是100%）。          | 它可能未充分利用CPU。                  |
| 它提高了处理器的效率和吞吐量。               | 它可能降低处理器的效率和吞吐量。       |

## 优先级调度和SJF的区别

最短作业优先（SJF）和优先调度算法的区别如下：

| 最短作业优先(SJF)                                                             | 优先调度                                                                                                 |
| ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| 最短作业优先（SJF）是根据进程的突发时间来执行的，即按照突发时间的升序来执行。 | 优先级调度是根据进程的优先级来执行的，即按照优先级的降序来执行。具有较高优先级的进程首先被执行。         |
| SJF也是非抢占性的，但是它的抢占性版本也被称为最短剩余时间优先（SRTF）算法。   | 优先级调度在本质上既是抢占性的也是非抢占性的。                                                           |
| 给定进程集的平均等待时间是最小的。                                            | 没有平均等待时间和响应时间的概念。                                                                       |
| SJF的真正困难在于知道下一个CPU请求或突发时间的长度。                          | 它很容易实现，而且最适合于实时操作系统。                                                                 |
| 一个长的进程可能永远不会被执行，而系统可能一直在执行短的进程。                | 进程阻塞的问题可以通过老化来解决，这意味着在一个固定的时间间隔后，以一个固定的数字逐渐增加进程的优先级。 |

## FCFS和RR调度的区别

先到先服务（FCFS）和循环（RR）调度算法的区别如下：

| First Come First Served (FCFS)       | Round Robin(RR)                                                        |
| ------------------------------------ | ---------------------------------------------------------------------- |
| FCFS是一种非抢占式的调度算法         | Round Robin（RR）是一种抢占式的调度算法。                              |
| FCFS的开销最小                       | 而RR的开销很小，因为它需要记录经过的时间，然后切换进程，这导致了开销。 |
| 为进程提供了很高的响应时间。         | 对于短的进程来说，响应时间非常低。                                     |
| FCFS在时间共享系统中不方便使用       | 它主要是为时间共享系统设计的，因此使用起来很方便。                     |
| 平均等待时间通常不是最小的。         | 平均等待时间是最小的。                                                 |
| 进程只是按照它们到达的顺序进行处理。 | 它与FCFS的处理方式相似，但使用时间量子。                               |

## SJF和RR调度的区别

最短作业优先（SJF）和循环（RR）调度算法的区别如下：

| 最短作业优先(SJF)                                                       | 循环轮转(RR)                                                                               |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| 根据进程的突发时间执行进程，即按突发时间的升序执行。                    | 根据定义的时间量来执行进程，即每个进程执行一个固定的时间量。                               |
| SJF也是非抢占式的，但其抢占式版本也被称为最短剩余时间优先（SRTF）算法。 | Round-Robin（RR）在本质上是抢占式的。                                                      |
| 给定的一组进程的平均等待时间是最小的。                                  | 给定进程集的平均等待时间相当小，取决于时间量子。                                           |
| SJF的真正困难在于知道下一个CPU请求或突发的长度。                        | 实现RR是很容易的。                                                                         |
| 一个长的进程可能永远不会被执行，系统可能会继续执行短的进程。            | 每个进程都被执行，每个用户都觉得他的工作被完成了，因为CPU给每个进程的时间是相等的。        |
| 在SJF的情况下，应该记录经过的时间，这将导致处理器上的更多开销。         | 在RR的情况下，如果时间量子非常小，那么上下文切换就会在很短的时间间隔内反复发生，导致开销。 |

## SRTF和LRTF

最短剩余作业优先（SRJF，SRTF，Shortest remaining job first ）：最短剩余作业优先也叫最短剩余时间优先，是最短作业优先调度算法的抢占式版本。在最短剩余作业优先中，具有最小的运行时间（即剩余时间）的进程被安排在下一个运行，在SRJF中，如果一个新的进程到达CPU调度器，需要更少的突发时间来执行，一个正在运行的进程将被抢占。

最长剩余作业优先（LRJF，LRTF，Longest remaining job）：最长剩余工作优先也叫最长剩余时间优先，与SRJF完全相反。在这种类型的CPU调度中，具有最长处理时间的进程被安排在下一个运行，如果一个具有更长突发时间的新进程进入队列，正在运行的进程将被抢占。

差异表:

| 最短剩余作业优先(SRJF)                                                         | 最长剩余作业优先(LRJF)                                             |
| ------------------------------------------------------------------------------ | ------------------------------------------------------------------ |
| 短的进程首先被执行，在任何时刻，如果一个时间较短的进程到达时，它将被首先执行。 | 长进程先被执行，在任何时刻，如果有一个长进程出现，它将被首先执行。 |
| 平均周转时间较小，因此它比LFJT更有效。                                         | 平均周转时间时间和等待时间较大，因此降低了操作系统的有效性。       |
| 它不会导致车队效应                                                             | 它将导致车队效应。                                                 |
| 在较少的时间内执行更多的进程                                                   | 在一定的时间内执行较少的进程                                       |

## MLQ和MLFQ区别

在多进程环境中，经常发生不止一个进程同时竞争CPU资源的情况。如果只有一个CPU可用，就必须在下一个运行的进程之间做出选择。操作系统中负责选择进程的部分被称为调度器，它使用的算法被称为调度算法。

多任务（multi programming）的目的是使CPU的利用率最大化。像周转时间、响应时间、等待时间、吞吐量这样的标准被建议在此基础上对调度算法进行判断。有许多CPU调度算法，其中两个是：

- 多级队列调度
- 多级反馈队列调度

多级队列（MLQ）和多级反馈队列（MLFQ）CPU调度算法之间的区别：

| 多级队列调度（MLQ）                                                                                                                                                | 多级反馈队列调度（MLFQ）                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| 这是一种队列调度算法，在这种算法中，准备好的队列被分割成几个较小的队列，进程被永久性地分配到这些队列中。进程是根据其固有的特性，如**内存大小、优先级**等来划分的。 | 在这种算法中，准备好的队列被划分为较小的队列，其依据是**CPU的突发特性**。进程不是永久性地分配到一个队列中，而是允许在队列之间移动。                   |
| 在这种算法中，队列被分为两组，第一组包含后台进程，第二组包含前台进程。使用Round Robin算法，80%的CPU时间被分配给前台队列，使用FCFS算法，20%的时间被分配给后台进程。 | 这里，队列被分为高优先级队列和低优先级队列。如果进程的执行时间较长，它就被移到低优先级队列中。因此，这种算法将I/O密集和交互式进程留在高优先级队列中。 |
| 在这个算法中，优先级是固定的。当一个队列中的所有进程被完全执行后，只有其他队列中的进程被执行。因此，可能会出现饥饿现象。                                           | 进程的优先级是动态的，因为进程被允许在队列之间移动。在低优先级队列中花费较多时间的进程可以转移到高优先级队列中，反之亦然。因此，它可以防止饿死。      |
| 由于进程不在队列之间移动，它的调度开销很低，但是不灵活。                                                                                                           | 由于进程被允许在队列之间移动，它的调度开销很高，但是很灵活。                                                                                          |

## 长期和短期调度的区别

长期调度器（Long-Term Scheduler）也被称为工作调度器（Job Scheduler）。长期调度器负责管理被选入系统进行处理的程序。在这个过程中，程序被设置在队列中，并根据要求选择最好的一个工作，并从工作池中获取进程。它规定了多任务的程度（DOM，Degree of Multi-programming）。短期调度器（Short-Term Scheduler）也被称为CPU调度器（CPU Scheduler）。短期调度器确保哪个程序是适合或的优先级足够被处理。它调节较少的DOM。

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.1vxtfdvsu6.webp)

长期和短期调度器之间的区别：

| 长时间调度器                                                   | 短时间调度器                                     |
| -------------------------------------------------------------- | ------------------------------------------------ |
| 长期调度器从作业池中获取进程。                                 | 短期调度器从准备好的队列中获取进程。             |
| 长期调度器也被称为作业调度器。                                 | 短期调度器也被称为CPU调度器。                    |
| 在长期调度器中，程序被设置在队列中并根据要求选择最适合的工作。 | 在短期调度器中不存在这样的队列。                 |
| 它规定了更多的DOM（多程序化程度）。                            | 它规定了更少的DOM（多程序化程度）。              |
| 它调节被选择到系统中进行处理的程序                             | 确保哪些程序是适合或重要的处理。                 |
| 与短期调度器相比，它的速度较低。                               | 与长期调度器相比，它的速度非常快。               |
| 长期调度器将进程的状态从 "New"改为 "Ready"                     | 短期调度器将进程的状态从 "Ready"改为 "Running"。 |
| 分时操作系统（Time-sharing operating systems）没有长期调度器。 | 在分时系统中它可能是最小的。                     |
| 它选择一个好的进程，混合I/O和CPU密集进程。                     | 它经常（frequently）为一个CPU选择一个新的进程。  |
| 长期调度器控制多编程（Multi-Programming）                      | 短期调度控制多任务（Multitasking）               |

## SJF和LJF的区别

| 最短作业优先(SJF)                                            | 最长作业优先(LJF)                                                            |
| ------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| 先执行短进程，然后再执行长进程。                             | 长的进程先执行，然后是短的进程。                                             |
| 吞吐量增加，因为在较短的时间内可以执行更多的进程。           | 吞吐量减少，因为在一定时间内可以执行的进程较少。                             |
| 它不会导致车队效应（convoy effect）。                        | 它可能导致车队效应。                                                         |
| 它的平均周转时间和平均等待时间较小，因此提高了系统的有效性。 | 它的平均周转时间和平均等待时间非常大。这导致处理速度慢，降低了系统的有效性。 |
| 突发时间长的进程可能会饿死。                                 | 突发时间较短的进程可能会饿死。                                               |

## CPU和GPU的区别

中央处理单元（CPU，Central Processing Unit ）：中央处理器被称为每个集成系统的大脑。中央处理器包括算术逻辑单元（ALU，arithmetic logic unit），用于快速存储信息和进行计算，控制单元（CU，Control Unit）用于执行指令排序和代码分支。CPU与更多的计算机组件互动，如内存、输入和输出，以执行指令（performing instruction）。

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.60h5af4m68w0.webp)

图形处理单元（GPU，Graphics Processing Unit）：GPU用于提供计算机游戏中的图像计算和渲染。GPU的速度比CPU的速度快，它强调高吞吐量（high throughput）。它通常与电子设备结合在一起，与电子设备（electronic equipment）共享RAM，这对最重要的计算任务来说是很好的。它比CPU包含更多的ALU单元。

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.4dmecfst79y0.webp)

CPU和GPU之间的基本区别是，CPU强调的是**低延迟**。而GPU则强调**高吞吐量**。

让我们来看看CPU和GPU之间的区别：

| CPU                                             | GPU                                  |
| ----------------------------------------------- | ------------------------------------ |
| CPU代表中央处理单元                             | 而GPU代表图形处理单元                |
| CPU比GPU消耗或需要更多的内存                    | 而它比CPU消耗或需要更少的内存        |
| CPU的速度低于GPU的速度                          | 而GPU的速度比CPU快                   |
| CPU包含微小的强大核心（minute powerful cores）  | 而它包含更多的弱小核心               |
| CPU适合串行指令（serial instruction）的处理     | 而GPU不适合串行指令的处理            |
| CPU不适合并行指令（parallel instruction）的处理 | 而GPU适合并行指令的处理              |
| CPU强调低延迟（low latency）                    | 而GPU强调高吞吐量（high throughput） |

## 抢占式和合作式多任务的区别

多任务是指在一段时期内同时执行多个任务或进程的方法。抢占式和合作式多任务是多任务的两种类型。

在抢占式多任务（preemptive multitasking）中，操作系统可以启动从运行中的进程到另一个进程的上下文切换。换句话说，操作系统允许停止当前运行进程的执行，并将CPU分配给其他进程。操作系统使用一些标准来决定一个进程应该执行多长时间才允许另一个进程使用CPU资源。从一个进程手中夺取操作系统的控制权并将其交给另一个进程的机制被称为抢占或预占（preempting or preemption）。

在合作式多任务（cooperative multitasking）中，操作系统从不启动从运行中的进程到另一个进程的上下文切换。只有当进程定期自愿让出控制权，或在空闲或逻辑上受阻（logically blocked）时才会发生上下文切换，以允许多个应用程序同时执行。另外，在这种多任务处理中，所有的进程都要合作以使调度方案发挥作用。

让我们看看抢占式多任务和合作式多任务之间的区别：

| 抢占式多任务                                                                                 | 合作式多任务                                                                                                   |
| -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| 抢占式多任务是操作系统来决定一个任务在允许另一个任务使用操作系统之前应该执行多长时间的任务。 | 合作式多任务是计算机多任务的一种类型，在这种类型中，操作系统从不启动从一个运行的进程到另一个进程的上下文切换。 |
| 它中断应用程序并将控制权交给应用程序控制之外的其他进程。                                     | 在合作多任务中，进程调度器从不意外地中断一个进程。                                                             |
| 操作系统可以发起从一个正在运行的进程到另一个进程的上下文切换。                               | 操作系统不会发起从一个正在运行的进程到另一个进程的上下文切换。                                                 |
| 恶意程序发起无限循环，它只伤害自己而不影响其他程序或线程。                                   | 恶意程序可以通过忙于等待或运行无限循环而不放弃控制，使整个系统停顿。                                           |
| 抢占式多任务迫使应用程序共享CPU，无论它们是否愿意。                                          | 在合作式多任务中，所有程序都必须合作，才能发挥作用。如果一个程序不合作，它就会霸占CPU。                        |
| UNIX、Windows 95、Windows NT操作系统是抢占式多任务的例子。                                   | Macintosh OS version 8.0-9.2.2和Windows 3.x操作系统是合作式多任务的例子。                                      |

## CPU调度标准

不同的CPU调度算法有不同的特性，对特定算法的选择取决于各种因素。许多标准已经被建议用于比较CPU调度算法：

这些标准包括以下几个方面：

- CPU的利用率。任何CPU调度算法的主要目标都是使CPU尽可能的繁忙。理论上，CPU的利用率可以从0到100，但在一个实时系统中，它从40%到90%不等，取决于系统的负载。
- 吞吐量（Throughput）：衡量CPU所做工作的一个标准是每单位时间内被执行和完成的进程数量。这就是所谓的吞吐量。吞吐量可能根据进程的长度或持续时间而变化。
- 周转时间（Turnaround time）。对于一个特定的进程，一个重要的标准是执行该进程需要多长时间。从提交一个进程到完成的时间被称为周转时间。周转时间是等待进入内存、在准备队列中等待、在CPU中执行和等待I/O的时间之和。周转时间 = 编译时间 - 到达时间（Turn Around Time = Compilation Time – Arrival Time）。
- 等待时间（Waiting time）。调度算法并不影响进程开始执行后完成所需的时间。它只影响进程的等待时间，即进程在准备队列中等待的时间。等待时间=周转时间-突发时间（Waiting Time = Turnaround Time – Burst Time）。
- 响应时间（Response time）。在一个交互式系统中，周转时间不是最好的标准。一个进程可能会相当早地产生一些输出，并在将以前的结果输出给用户之后继续计算新的结果。因此，另一个标准是从提交请求的过程到产生第一个响应的时间。这个衡量标准被称为响应时间。响应时间=CPU分配时间（当CPU首次分配）-到达时间（Response Time = CPU Allocation Time(when the CPU was allocated for the first) – Arrival Time）。
- 完成时间（Completion time）。这是该进程完成执行的时间。

## CPU调度中的时间切片

CPU的内核并不简单地将我们PC的全部资源分配给单个进程或服务。CPU不断地运行许多进程，这些进程对它的运行至关重要，因此我们的内核需要毫不延迟地管理这些进程。当程序需要运行时，必须为其创建进程。这个进程需要拥有重要的资源，如RAM和CPU。内核为CPU安排时间片（time slice），以执行进程中的命令和指令。尽管如此，只有一个CPU和众多进程。

CPU是如何做到无延迟地执行不同的进程的呢？它是通过一个一个地按时间片来执行进程的。时间片是分配给CPU执行进程的短暂时间帧（time frame）。

### 时间片

它是在抢占式多任务CPU中分配给进程运行的时间帧。调度器在每一个时间片上运行每个进程。每个时间片的周期（period）是非常重要的，对平衡CPU的性能（performance）和响应性（responsiveness）至关重要。如果时间片很短，调度器将花费更多的处理时间；相反，如果时间片太长，调度器将再次花费更多的处理时间。

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.6belxdpaq380.webp)

当进程被分配到CPU时，时钟定时器（clock timer）被设置为对应的时间片：

- 如果进程在时间片之前完成突发（burst），CPU就像传统的FCFS一样简单地将其换出。
- 如果时间片先结束，CPU就把它移到正在进行的队列的后面。

正在进行的队列（ongoing queue）是像循环队列（circular queue）一样管理的，所以，在所有进程被执行一次后，调度器会再次执行第一个进程，然后是第二个，依此类推。

## 参考

- 更多调度算法参见：[Deadline Monotonic CPU Scheduling](https://www.geeksforgeeks.org/deadline-monotonic-cpu-scheduling/)