# 图解JavaScript之原型继承

## 目录

[[TOC]]

## 原型继承

你有没有想过为什么我们可以在字符串、数组或对象上使用诸如`.length`、`.split()`、`.join（）`这些内置方法呢？我们从来没有明确指定过它们，它们到底是从哪里来的呢？现在别说“哈哈，没人知道，这就是神奇的JavaScript🧚🏻‍♂️”。这实际上是因为一种叫做**原型继承**（prototypal inheritance）的玩意儿。它很棒，而且我们用到它的次数意想不到的多！

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/oxygen-space/image.3slsu8co0mo0.webp)

我们经常要创建很多相同类型的对象。假设我们有一个网站，在这个网站上，人们可以浏览狗！对每一只狗，我们都需要对象来表示它！🐕 我们用不着每次都写一个新对象，而是用一个构造器函数（constructor function）（我知道你在想什么，稍后我将介绍ES6类！），用`new`关键字创建Dog**实例**（不过，本文并非是要解释构造器函数，所以我不想谈太多）。每只狗都有名字（name）、品种（breed）、颜色（color）以及一个bark()函数！

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--pDfw39RK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/caurw7uuk62htpldgtln.png)

当我们创建`Dog`构造器函数时，它并不是我们创建的唯一对象。我们还自动创建了另一个对象，称为**prototype（原型）**！默认情况下，这个对象包含一个**constructor**属性，它只是对原始构造器函数的引用，在本例中是`Dog`。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--dWGIZ_zz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/9howj4i3zvlgun3svppp.gif)

当我们创建一个构造器函数时，同时也创建了一个prototype对象。其构造器有一个对原始构造器函数的引用。

Dog构造器函数上的`prototype`属性是不可枚举（non-enumerable）的，也就是说，当我们试图访问该对象的属性时，它是不会出现。但它依然存在！

好吧，那么为什么我们会有这个属性对象呢？首先，我们来创建一些我们想展示的狗。为简单起见，我叫它们`dog1`和`dog2`。`dog1`是Daisy，一只可爱的黑色拉布拉多犬！`dog2`是Jack，一只无畏的白色杰克罗素犬！😎

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--O_jSVpBB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/lyajz4lade30ci2koirq.png)

下面我们把`dog1`输出到控制台，并展开其属性！

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--cA-2FOVV--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/tt4yfoz8ckmxfofv3f9v.gif)

我们可以看到添加的属性，如`name`、`breed`、`color`和`bark`。但是`__proto__` 属性是什么玩意！它是不可枚举的，也就是说当我们试图获取对象的该属性时，它通常不会出现。下面我们把它展开！😃

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--zxO-eMV0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/dye57pcku5cfaz0er60c.gif)

它看起来就像`Dog.prototype`对象！其实`__proto__`就是对`Dog.prototype`对象的一个引用。这就是**原型继承**的目的：**构造器的每个实例都可以访问构造器的原型**！🤯

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--FBGV--dx--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/t6kiav029gl2e0hv1xct.gif)

实例也包含一个`__proto__`属性，这是对实例的构造器的原型的引用，在本例中是Dog.prototype。

为什么这很酷呢？有时我们有一些所有实例都共享的属性。比如本例中的`bark`函数：它对每个实例都是完全相同的，那么与其每次创建一个新的dog时都创建一个新函数，每次都消耗内存，还不如将其添加到`Dog.prototype`对象！🥳

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--2026kdwz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/59nlnyqioosaowj09xn8.gif)

我们将属性添加到所有实例都可以共享的原型上，而不是每次创建该属性的新副本。

每当我们试图访问实例上的属性时，引擎首先在本地（locally）搜索，看看该属性是否在对象本身上定义。不过，如果找不到我们要访问的属性，那么引擎就会通过`__proto__`属性**沿着原型链**（prototype chain）遍历！

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--gg5KU5nB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/fabyyjot1s78mttyzzk8.gif)

当试图访问一个对象上某个属性时，引擎首先在本地搜索。然后，通过`__proto__`属性沿着原型链遍历。

现在这只是一个步骤，但它可以包含几个步骤！如果继续往下看，我们就可能会注意到，当展开`__proto__`对象时，并没有包含一个显示`Dog.prototype`的属性。`Dog.prototype`本身是一个对象，也就是说它实际上是`Object`构造器的一个实例！这意味着`Dog.prototype`也包含一个`__proto__`属性，这个属性是对`Object.prototype`的一个引用！

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--vJ7k8Gb3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/8vk5w6loliot818f2lcd.gif)

最后，我们就有了所有内置方法来自何方的答案：它们在原型链上！😃

比如`.toString（）`方法。它是在`dog1`对象上本地定义的吗？不是的，它是定义在`dog1.__proto__`的引用，即`Dog.prototype`对象上的吗？也不是！它是定义在`Dog.prototype.__proto__`的引用，即`Object.prototype`对象上的吗？是的！🙌🏼

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--16IwaVkk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/fpt5nndkbq5kau0nqeqj.gif)

原型链可以有几个步骤。比如，Dog.prototype本身是个对象，因而继承来自内置的Object.prototype的属性。

现在，我们刚刚用过了构造器函数（`function Dog() { ... }`)，它仍然是有效的JavaScript。不过，ES6实际上为构造器函数以及处理原型引入了一种更简单的语法：类（classes）！

::: warning 注意
类只是构造器函数的**语法糖**（syntactical sugar）。其工作机制还是一样的！
:::

我们用`class`关键字编写类。类有一个`constructor`函数，它基本上就是我们用ES5语法编写的构造器函数！我们要添加到原型中的属性是在类主体上定义的。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--3PePIjz5--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/qnbqubcipqjl5pb3i8ds.gif)

ES6引入了类，类是构造器函数的语法糖。

类的另一个好处是，我们可以很容易地**继承**（extend）其他类。

假设我们要展示几只相同品种的狗，即吉娃娃狗（chihuahua）！不管咋样，吉娃娃依然是狗。为简单起见，我们现在只保留一个`name`属性给Dog类。不过这些吉娃娃也可以做些特别的事情，它们的叫声很小（smallBark），它们的叫声不是`Woof!`，而是`Small woof!`。🐕

在继承的类中，我们可以使用`super`关键字访问父类的构造器。父类的构造器期望的参数，我们必须传递给`super`，在本例中是`name`。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--Fitn1c9K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/tx25dar3duqo0z2bpfam.png)

`myPet`既可以访问`Chihuahua.prototype`，又可以访问`Dog.prototype`（并且由于`Dog.prototype`是个对象，又可以自动访问`Object.prototype`）。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--WOeqUeM3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/qija16dju8t5j1ksy0ps.gif)

原型继承在类与ES5构造器上的工作机制是一样的。

由于`Chihuahua.prototype`有`smallBark`函数，而`Dog.Prototype`有`bark`函数，因此在`myPet`上，我们既可以访问`smallBark`，也可以访问`bark`！

我们可以料想得到，原型链不会永远持续下去。最终有一个原型等于`null`的对象，在本例中就是`Object.prototype`对象！如果我们尝试访问在本地或原型链上找不到的属性，就会返回`undefined`。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s---EseK2fk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/1905zxijp45soy0jzle2.gif)

我们可以调用从被继承的类所继承的方法。原型链在**proto**的值为null的时候结束。

::: tip
实际上，class 的 `__proto__` 应该先指向 `Function.prototype`，`Function.prototype.__proto__` 再指向 `Object.prototype`。
:::

尽管我在这里用**构造器函数和类**解释了将原型添加到对象的所有内容，但是将原型添加到对象还有一种方法，就是用`Object.create()`方法。用这个方法，我们可以创建一个新对象，并可以准确指定该对象的原型！💪🏼

为此，我们将**已有对象**作为参数传递给`Object.create`方法。该对象就是我们创建的对象的原型！（扩展：参见[Object.create()、new Object()和{}的区别](https://juejin.cn/post/6844903917835436045)）

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--uw9DJFU0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/kbwwsn1fd4gngd05tm9a.png)

下面输出我们刚刚创建的`me`对象。

![image](https://res.cloudinary.com/practicaldev/image/fetch/s--9sWtvaRG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/6zzt8zpy85gtitxmpwi9.gif)

我们没有向对象`me`添加任何属性，它仅包含不可枚举的`__proto__`属性！`__proto__`属性引用了我们定义为原型的对象：`person`对象，它有一个`name`和一个`age`属性。由于`person`对象是一个对象，因此`person`对象上的`__proto__`属性值就是`Object.prototype`。

希望你现在了解了为什么原型继承在JavaScript的世界中如此重要！

## 经典继承与原型继承

与大多数其他语言不同，JavaScript的对象系统是基于原型的，而不是基于类。不幸的是，大多数JavaScript开发者并不了解JavaScript的对象系统，也不知道如何将其发挥到最佳效果。还有一些人理解它，但希望它的行为更像基于类的系统（class based systems）。结果是，JavaScript的对象系统有一个令人困惑的人格分裂，这意味着JavaScript开发者需要对原型和类都有一定的了解。

### 类和原型继承之间的区别是什么

类的继承性（Class Inheritance）：一个类就像一个蓝图--对将要创建的对象的一些描述。类继承于其他类，并创建子类关系（subclass relationships）：层次化的类分类法（hierarchical class taxonomies）。

::: tip Class Inheritance
A class is like a blueprint — a description of the object to be created.
:::

实例通常是通过带有 "new "关键字的构造函数来实例化的。类的继承可以使用也可以不使用ES6的`class`关键字。你可能从Java等语言中了解到的**类在技术上并不存在于JavaScript**，而是使用构造函数（constructor functions）。ES6的`class`关键字可以解构为一个构造函数（desugars）。

```js
class Foo {}
typeof Foo // 'function'
```

在JavaScript中，类的继承是在原型继承（prototypal inheritance）的基础上实现的，但这并不意味着它做了同样的事情。

JavaScript的类继承使用原型链（prototype chain）将子类`Constructor.prototype`与父类`Constructor.prototype`连接起来进行委托（delegation）。通常情况下，也会调用`super()`构造函数。这些步骤形成了单祖先的父/子层次结构（single-ancestor parent/child hierarchies），并在OO设计中创造了最紧密的耦合。

>"类继承于类，并建立子类关系：分层的类分类法。"
>
> “Classes inherit from classes and create subclass relationships: hierarchical class taxonomies.”

::: tip 总结
一个类就像一个蓝图。创建一个对象的经典方法是使用CLASS声明（CLASS declaration）来定义对象的结构，并将该类实例化（instantiate）来创建一个新的对象。以这种方式创建的对象有它们自己的所有实例属性的副本（copies），加上每个实例方法的单一副本的链接。继承（Inheritance）是OO设计中可用的最紧密的耦合（tightest coupling）。而且，子代类（descendant classes）对它们的祖代类（ancestor classes）有很深的了解。
:::

## 参考

- [继承与原型链 - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [Master the JavaScript Interview: What’s the Difference Between Class & Prototypal Inheritance? | by Eric Elliott | JavaScript Scene | Medium](https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9)
